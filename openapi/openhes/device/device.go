// Package device provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package device

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/cybroslabs/hes-2-apis/openapi/openhes/attribute"
	externalRef0 "github.com/cybroslabs/hes-2-apis/openapi/openhes/driver"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// AttributesSchema Schema that describes a set of attributes and their values. The key is the property name and the value is the property value. The value can be of type string, integer, number, boolean, binary, or null.
type AttributesSchema = attribute.Attributes

// CommunicationUnitID The ID of the communication unit. The ID must be unique across all OpenHES components.
type CommunicationUnitID = openapi_types.UUID

// CommunicationUnitListID The list of communication unit IDs.
type CommunicationUnitListID = []CommunicationUnitID

// CommunicationUnitSchema Schema that describes communication unit details.
type CommunicationUnitSchema struct {
	ConnectionInfo ConnectionInfoSchema `json:"connectionInfo"`

	// ExternalID The public ID of the communication unit.
	ExternalID *string `json:"externalID"`

	// Id The ID of the communication unit. The ID must be unique across all OpenHES components.
	Id CommunicationUnitID `json:"id"`

	// Name The name of the communication unit.
	Name string `json:"name"`
}

// ConnectionInfoSchema defines model for ConnectionInfoSchema.
type ConnectionInfoSchema struct {
	// LinkProtocol The type of the data-link layer.
	//   * `IEC_62056_21` - The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
	//   * `HDLC` - The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
	//   * `COSEM_WRAPPER` - The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
	//   * `MODBUS` - The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
	//   * `MBUS` - The M-Bus protocol. It shall be used for M-Bus application protocol.
	//   * `NOT_APPLICABLE` - The data link protocol is not applicable. It's useful for listening communication type.
	LinkProtocol externalRef0.DataLinkProtocolSchema `json:"linkProtocol"`
	Union        json.RawMessage
}

// ConnectionTypePhoneLineSchema Schema that describes the phone line (modem) connection.
type ConnectionTypePhoneLineSchema struct {
	// Number The phone number of the device.
	Number string `json:"number"`

	// PoolId The modem pool ID.
	PoolId    openapi_types.UUID `json:"pool_id"`
	TypeModem int                `json:"type_modem"`
}

// ConnectionTypeSerialDirectSchema Schema that describes the direct IP to serial connection. It represents simple physical line without any on-demand confiration (e.g. speed or parity) as the configuration is statically set on the IP-to-serial device.
type ConnectionTypeSerialDirectSchema struct {
	// Host The IP address or the hostname of the device.
	Host string `json:"host"`

	// Port The port number of the device.
	Port             uint32 `json:"port"`
	TypeSerialDirect int    `json:"type_serial_direct"`
}

// ConnectionTypeSerialMoxaSchema Schema that describes the IP-to-serial connection using a Moxa device. The Moxa supports dynamic serial configuration changes via command connection.
type ConnectionTypeSerialMoxaSchema struct {
	// CommandPort The port number of the device.
	CommandPort uint32 `json:"commandPort"`

	// DataPort The port number of the device.
	DataPort uint32 `json:"dataPort"`

	// Host The IP address or the hostname of the device.
	Host           string `json:"host"`
	TypeSerialMoxa int    `json:"type_serial_moxa"`
}

// ConnectionTypeTcpIpSchema Schema that describes the TCP/IP connection.
type ConnectionTypeTcpIpSchema struct {
	// Host The IP address or the hostname of the device.
	Host string `json:"host"`

	// Port The port number of the device.
	Port    uint32 `json:"port"`
	TypeTcp int    `json:"type_tcp"`
}

// DeviceGroupID The ID of the device group. The ID must be unique across all OpenHES components.
type DeviceGroupID = openapi_types.UUID

// DeviceGroupSchema Schema that describes device group details.
type DeviceGroupSchema struct {
	// ExternalID The public ID of the device group.
	ExternalID *string `json:"externalID"`

	// Id The ID of the device group. The ID must be unique across all OpenHES components.
	Id DeviceGroupID `json:"id"`

	// Name The name of the device group.
	Name string `json:"name"`
}

// DeviceID The ID of the device. The ID must be unique across all OpenHES components.
type DeviceID = openapi_types.UUID

// DeviceSchema Schema that describes device details.
type DeviceSchema struct {
	// Attributes Schema that describes a set of attributes and their values. The key is the property name and the value is the property value. The value can be of type string, integer, number, boolean, binary, or null.
	Attributes AttributesSchema `json:"attributes"`

	// CommunicationUnitID The list of communication unit IDs.
	CommunicationUnitID CommunicationUnitListID `json:"communicationUnitID"`

	// ExternalID The public ID of the device.
	ExternalID *string `json:"externalID"`

	// Id The ID of the device. The ID must be unique across all OpenHES components.
	Id DeviceID `json:"id"`

	// Name The name of the device.
	Name string `json:"name"`

	// Timezone The timezone of the device.
	Timezone *string `json:"timezone"`
}

// ModemConnectionSchema Schema that describes modem connection details. Currently only TCP/IP connection is supported.
type ModemConnectionSchema struct {
	Union json.RawMessage
}

// ModemPoolSchema Schema that describes modem pool details.
type ModemPoolSchema struct {
	// Id The modem pool identifier. It is automatically generated during creation.
	Id openapi_types.UUID `json:"id"`

	// Name The name of the modem pool.
	Name string `json:"name"`
}

// ModemSchema Schema that describes modem details.
type ModemSchema struct {
	// AtConfig The modem configuration command.
	AtConfig string `json:"at_config"`

	// AtDial The modem dial command.
	AtDial string `json:"at_dial"`

	// AtDsr The modem DSR command.
	AtDsr bool `json:"at_dsr"`

	// AtEscape The modem escape command.
	AtEscape string `json:"at_escape"`

	// AtHangup The modem hangup command.
	AtHangup string `json:"at_hangup"`

	// AtInit The modem initialization command.
	AtInit string `json:"at_init"`

	// AtTest The modem test command.
	AtTest string `json:"at_test"`

	// ConnectTimeout The modem connection timeout in seconds.
	ConnectTimeout uint32 `json:"connect_timeout"`

	// Connection Schema that describes modem connection details. Currently only TCP/IP connection is supported.
	Connection ModemConnectionSchema `json:"connection"`

	// Id The modem identifier. It is automatically generated during creation.
	Id openapi_types.UUID `json:"id"`

	// Name The name of the modem.
	Name string `json:"name"`
}

// AsConnectionTypeTcpIpSchema returns the union data inside the ConnectionInfoSchema as a ConnectionTypeTcpIpSchema
func (t ConnectionInfoSchema) AsConnectionTypeTcpIpSchema() (ConnectionTypeTcpIpSchema, error) {
	var body ConnectionTypeTcpIpSchema
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromConnectionTypeTcpIpSchema overwrites any union data inside the ConnectionInfoSchema as the provided ConnectionTypeTcpIpSchema
func (t *ConnectionInfoSchema) FromConnectionTypeTcpIpSchema(v ConnectionTypeTcpIpSchema) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeConnectionTypeTcpIpSchema performs a merge with any union data inside the ConnectionInfoSchema, using the provided ConnectionTypeTcpIpSchema
func (t *ConnectionInfoSchema) MergeConnectionTypeTcpIpSchema(v ConnectionTypeTcpIpSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsConnectionTypePhoneLineSchema returns the union data inside the ConnectionInfoSchema as a ConnectionTypePhoneLineSchema
func (t ConnectionInfoSchema) AsConnectionTypePhoneLineSchema() (ConnectionTypePhoneLineSchema, error) {
	var body ConnectionTypePhoneLineSchema
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromConnectionTypePhoneLineSchema overwrites any union data inside the ConnectionInfoSchema as the provided ConnectionTypePhoneLineSchema
func (t *ConnectionInfoSchema) FromConnectionTypePhoneLineSchema(v ConnectionTypePhoneLineSchema) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeConnectionTypePhoneLineSchema performs a merge with any union data inside the ConnectionInfoSchema, using the provided ConnectionTypePhoneLineSchema
func (t *ConnectionInfoSchema) MergeConnectionTypePhoneLineSchema(v ConnectionTypePhoneLineSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsConnectionTypeSerialMoxaSchema returns the union data inside the ConnectionInfoSchema as a ConnectionTypeSerialMoxaSchema
func (t ConnectionInfoSchema) AsConnectionTypeSerialMoxaSchema() (ConnectionTypeSerialMoxaSchema, error) {
	var body ConnectionTypeSerialMoxaSchema
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromConnectionTypeSerialMoxaSchema overwrites any union data inside the ConnectionInfoSchema as the provided ConnectionTypeSerialMoxaSchema
func (t *ConnectionInfoSchema) FromConnectionTypeSerialMoxaSchema(v ConnectionTypeSerialMoxaSchema) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeConnectionTypeSerialMoxaSchema performs a merge with any union data inside the ConnectionInfoSchema, using the provided ConnectionTypeSerialMoxaSchema
func (t *ConnectionInfoSchema) MergeConnectionTypeSerialMoxaSchema(v ConnectionTypeSerialMoxaSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

// AsConnectionTypeSerialDirectSchema returns the union data inside the ConnectionInfoSchema as a ConnectionTypeSerialDirectSchema
func (t ConnectionInfoSchema) AsConnectionTypeSerialDirectSchema() (ConnectionTypeSerialDirectSchema, error) {
	var body ConnectionTypeSerialDirectSchema
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromConnectionTypeSerialDirectSchema overwrites any union data inside the ConnectionInfoSchema as the provided ConnectionTypeSerialDirectSchema
func (t *ConnectionInfoSchema) FromConnectionTypeSerialDirectSchema(v ConnectionTypeSerialDirectSchema) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeConnectionTypeSerialDirectSchema performs a merge with any union data inside the ConnectionInfoSchema, using the provided ConnectionTypeSerialDirectSchema
func (t *ConnectionInfoSchema) MergeConnectionTypeSerialDirectSchema(v ConnectionTypeSerialDirectSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t ConnectionInfoSchema) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.Union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["linkProtocol"], err = json.Marshal(t.LinkProtocol)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'linkProtocol': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ConnectionInfoSchema) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["linkProtocol"]; found {
		err = json.Unmarshal(raw, &t.LinkProtocol)
		if err != nil {
			return fmt.Errorf("error reading 'linkProtocol': %w", err)
		}
	}

	return err
}

// AsConnectionTypeTcpIpSchema returns the union data inside the ModemConnectionSchema as a ConnectionTypeTcpIpSchema
func (t ModemConnectionSchema) AsConnectionTypeTcpIpSchema() (ConnectionTypeTcpIpSchema, error) {
	var body ConnectionTypeTcpIpSchema
	err := json.Unmarshal(t.Union, &body)
	return body, err
}

// FromConnectionTypeTcpIpSchema overwrites any union data inside the ModemConnectionSchema as the provided ConnectionTypeTcpIpSchema
func (t *ModemConnectionSchema) FromConnectionTypeTcpIpSchema(v ConnectionTypeTcpIpSchema) error {
	b, err := json.Marshal(v)
	t.Union = b
	return err
}

// MergeConnectionTypeTcpIpSchema performs a merge with any union data inside the ModemConnectionSchema, using the provided ConnectionTypeTcpIpSchema
func (t *ModemConnectionSchema) MergeConnectionTypeTcpIpSchema(v ConnectionTypeTcpIpSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.Union, b)
	t.Union = merged
	return err
}

func (t ModemConnectionSchema) MarshalJSON() ([]byte, error) {
	b, err := t.Union.MarshalJSON()
	return b, err
}

func (t *ModemConnectionSchema) UnmarshalJSON(b []byte) error {
	err := t.Union.UnmarshalJSON(b)
	return err
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../driver/driver.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
