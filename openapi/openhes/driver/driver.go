// Package driver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package driver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/cybroslabs/hes-2-apis/openapi/k8s/containers"
	externalRef1 "github.com/cybroslabs/hes-2-apis/openapi/openhes/driver/driverdata"
	externalRef2 "github.com/cybroslabs/hes-2-apis/openapi/openhes/job"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for AttributeDefinitionSchemaType.
const (
	BINARY  AttributeDefinitionSchemaType = "BINARY"
	BOOLEAN AttributeDefinitionSchemaType = "BOOLEAN"
	INTEGER AttributeDefinitionSchemaType = "INTEGER"
	NUMBER  AttributeDefinitionSchemaType = "NUMBER"
	STRING  AttributeDefinitionSchemaType = "STRING"
)

// AttributeDefinitionSchema Schema that describes a driver attribute.
type AttributeDefinitionSchema struct {
	DefaultValue *GenericObject `json:"defaultValue,omitempty"`

	// Description The description of the attribute.
	Description *string `json:"description,omitempty"`

	// Mandatory Indicates whether the attribute is mandatory or not.
	Mandatory *bool `json:"mandatory,omitempty"`

	// Name The name of the attribute.
	Name *string `json:"name,omitempty"`

	// Type The type of the attribute.
	//   * `STRING` - The attribute is a string.
	//   * `INTEGER` - The attribute is an integer.
	//   * `NUMBER` - The attribute is a decimal number.
	//   * `BOOLEAN` - The attribute is a boolean.
	//   * `BINARY` - The attribute is a binary.
	Type *AttributeDefinitionSchemaType `json:"type,omitempty"`
}

// AttributeDefinitionSchemaType The type of the attribute.
//   - `STRING` - The attribute is a string.
//   - `INTEGER` - The attribute is an integer.
//   - `NUMBER` - The attribute is a decimal number.
//   - `BOOLEAN` - The attribute is a boolean.
//   - `BINARY` - The attribute is a binary.
type AttributeDefinitionSchemaType string

// DriverActionAttributeSchema Schema that describes a driver action attribute.
type DriverActionAttributeSchema struct {
	// Attributes The list of attributes supported by the driver.
	Attributes *DriverAttributesSchema `json:"attributes,omitempty"`

	// Type The type of action.
	//   * `GET_REGISTER` - The action is to get a billing value, for example, instantaneous values.
	//   * `GET_PERIODICAL_PROFILE` - The action is to get a periodical profile, for example, load-profile.
	//   * `GET_IRREGULAR_PROFILE` - The action is to get a non-periodical profile, for, daily profile or monthly billing registers.
	//   * `GET_EVENTS` - The action is to get an event log.
	//   * `GET_CLOCK` - The action is to get the clock.
	//   * `SYNC_CLOCK` - The action is to synchronize the clock. The action synchronizes the clock in the device. If the force attribute is set, it forcefully sets the clock.
	//   * `GET_RELAY_STATE` - The action is to get the relay state.
	//   * `SET_RELAY_STATE` - The action is to set the relay state.
	//   * `GET_DISCONNECTOR_STATE` - The action is to get the disconnector state.
	//   * `SET_DISCONNECTOR_STATE` - The action is to set the disconnector state.
	//   * `GET_TOU` - The action is to get the time-of-use table.
	//   * `SET_TOU` - The action is to set the time-of-use table.
	//   * `GET_LIMITER` - The action is to get the limiter settings.
	//   * `SET_LIMITER` - The action is to set the limiter settings.
	//   * `RESET_BILLING_PERIOD` - The action is to reset the billing period.
	//   * `FW_UPDATE` - The action is to start a firmware update.
	Type *externalRef2.ActionTypeSchema `json:"type,omitempty"`
}

// DriverAttributesSchema The list of attributes supported by the driver.
type DriverAttributesSchema = []AttributeDefinitionSchema

// DriverDetailsSchema Schema that describes the communication driver details.
type DriverDetailsSchema = DriverSchema

// DriverSchema Schema that describes the communication driver details.
type DriverSchema struct {
	// Spec Schema that registers new or updates already registered communication drivers.
	Spec *DriverSpecSchema `json:"spec,omitempty"`
}

// DriverSpecSchema Schema that registers new or updates already registered communication drivers.
type DriverSpecSchema struct {
	DriverType string `json:"driverType"`
	Image      string `json:"image"`

	// Resources Resource values for a container.
	Resources externalRef0.ContainerResourcesSetSchema `json:"resources"`
}

// GenericObject defines model for GenericObject.
type GenericObject = interface{}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../../k8s/containers/containers.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(pathPrefix, "../../openhes/driver/driverdata/driverdata.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(pathPrefix, "../job/job.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
