// Package driver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package driver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/cybroslabs/hes-2-apis/openapi/openhes/driver/driverdata"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for ActionTypeSchema.
const (
	FWUPDATE             ActionTypeSchema = "FW_UPDATE"
	GETCLOCK             ActionTypeSchema = "GET_CLOCK"
	GETDISCONNECTORSTATE ActionTypeSchema = "GET_DISCONNECTOR_STATE"
	GETEVENTS            ActionTypeSchema = "GET_EVENTS"
	GETIRREGULARPROFILE  ActionTypeSchema = "GET_IRREGULAR_PROFILE"
	GETLIMITER           ActionTypeSchema = "GET_LIMITER"
	GETPERIODICALPROFILE ActionTypeSchema = "GET_PERIODICAL_PROFILE"
	GETREGISTER          ActionTypeSchema = "GET_REGISTER"
	GETRELAYSTATE        ActionTypeSchema = "GET_RELAY_STATE"
	GETTOU               ActionTypeSchema = "GET_TOU"
	RESETBILLINGPERIOD   ActionTypeSchema = "RESET_BILLING_PERIOD"
	SETDISCONNECTORSTATE ActionTypeSchema = "SET_DISCONNECTOR_STATE"
	SETLIMITER           ActionTypeSchema = "SET_LIMITER"
	SETRELAYSTATE        ActionTypeSchema = "SET_RELAY_STATE"
	SETTOU               ActionTypeSchema = "SET_TOU"
	SYNCCLOCK            ActionTypeSchema = "SYNC_CLOCK"
)

// Defines values for ApplicationProtocolSchema.
const (
	ApplicationProtocolSchemaANSIC12    ApplicationProtocolSchema = "ANSI_C12"
	ApplicationProtocolSchemaDLMSLN     ApplicationProtocolSchema = "DLMS_LN"
	ApplicationProtocolSchemaDLMSSN     ApplicationProtocolSchema = "DLMS_SN"
	ApplicationProtocolSchemaIEC6205621 ApplicationProtocolSchema = "IEC_62056_21"
	ApplicationProtocolSchemaLIS200     ApplicationProtocolSchema = "LIS200"
	ApplicationProtocolSchemaMODBUS     ApplicationProtocolSchema = "MODBUS"
	ApplicationProtocolSchemaMQTT       ApplicationProtocolSchema = "MQTT"
	ApplicationProtocolSchemaSCTM       ApplicationProtocolSchema = "SCTM"
)

// Defines values for AttributeDefinitionSchemaType.
const (
	BINARY      AttributeDefinitionSchemaType = "BINARY"
	BOOLEAN     AttributeDefinitionSchemaType = "BOOLEAN"
	INTEGER     AttributeDefinitionSchemaType = "INTEGER"
	NUMBER      AttributeDefinitionSchemaType = "NUMBER"
	STRING      AttributeDefinitionSchemaType = "STRING"
	TIMESTAMP   AttributeDefinitionSchemaType = "TIMESTAMP"
	TIMESTAMPTZ AttributeDefinitionSchemaType = "TIMESTAMPTZ"
)

// Defines values for DataLinkProtocolSchema.
const (
	DataLinkProtocolSchemaCOSEMWRAPPER  DataLinkProtocolSchema = "COSEM_WRAPPER"
	DataLinkProtocolSchemaHDLC          DataLinkProtocolSchema = "HDLC"
	DataLinkProtocolSchemaIEC6205621    DataLinkProtocolSchema = "IEC_62056_21"
	DataLinkProtocolSchemaMBUS          DataLinkProtocolSchema = "MBUS"
	DataLinkProtocolSchemaMODBUS        DataLinkProtocolSchema = "MODBUS"
	DataLinkProtocolSchemaNOTAPPLICABLE DataLinkProtocolSchema = "NOT_APPLICABLE"
)

// ActionTypeSchema The type of action.
//   - `GET_REGISTER` - The action is to get a billing value, for example, instantaneous values.
//   - `GET_PERIODICAL_PROFILE` - The action is to get a periodical profile, for example, load-profile.
//   - `GET_IRREGULAR_PROFILE` - The action is to get a non-periodical profile, for, daily profile or monthly billing registers.
//   - `GET_EVENTS` - The action is to get an event log.
//   - `GET_CLOCK` - The action is to get the clock.
//   - `SYNC_CLOCK` - The action is to synchronize the clock. The action synchronizes the clock in the device. If the force attribute is set, it forcefully sets the clock.
//   - `GET_RELAY_STATE` - The action is to get the relay state.
//   - `SET_RELAY_STATE` - The action is to set the relay state.
//   - `GET_DISCONNECTOR_STATE` - The action is to get the disconnector state.
//   - `SET_DISCONNECTOR_STATE` - The action is to set the disconnector state.
//   - `GET_TOU` - The action is to get the time-of-use table.
//   - `SET_TOU` - The action is to set the time-of-use table.
//   - `GET_LIMITER` - The action is to get the limiter settings.
//   - `SET_LIMITER` - The action is to set the limiter settings.
//   - `RESET_BILLING_PERIOD` - The action is to reset the billing period.
//   - `FW_UPDATE` - The action is to start a firmware update.
type ActionTypeSchema string

// ApplicationProtocolSchema The type of the application layer.
//   - `IEC_62056_21` - The IEC 62056-21 (IEC-61107, VDEW) protocol.
//   - `DLMS_SN` - The DLMS short-name protocol.
//   - `DLMS_LN` - The DLMS logical-name protocol.
//   - `SCTM` - The SCTM protocol.
//   - `LIS200` - The LIS200 protocol.
//   - `ANSI_C12` - The ANSI C12 protocol.
//   - `MQTT` - The MQTT protocol.
//   - `MODBUS` - The Modbus protocol.
type ApplicationProtocolSchema string

// AttributeDefinitionSchema Schema that describes a driver attribute.
type AttributeDefinitionSchema struct {
	DefaultValue *GenericObject `json:"defaultValue,omitempty"`

	// Description The description of the attribute.
	Description *string `json:"description,omitempty"`

	// Mandatory Indicates whether the attribute is mandatory or not.
	Mandatory *bool `json:"mandatory,omitempty"`

	// Name The name of the attribute.
	Name *string `json:"name,omitempty"`

	// Type The type of the attribute.
	//   * `STRING` - The attribute is a string.
	//   * `INTEGER` - The attribute is an integer.
	//   * `NUMBER` - The attribute is a decimal number.
	//   * `BOOLEAN` - The attribute is a boolean.
	//   * `BINARY` - The attribute is a binary.
	//   * `TIMESTAMP` - The attribute is a timestamp; it shal not timezone-aware and it's always encoded as a UNIX timestamp number (~UTC).
	//   * `TIMESTAMPTZ` - The attribute is a timestamp; it is timezone-aware and it's always encoded as an ISO 8601 string.
	Type *AttributeDefinitionSchemaType `json:"type,omitempty"`
}

// AttributeDefinitionSchemaType The type of the attribute.
//   - `STRING` - The attribute is a string.
//   - `INTEGER` - The attribute is an integer.
//   - `NUMBER` - The attribute is a decimal number.
//   - `BOOLEAN` - The attribute is a boolean.
//   - `BINARY` - The attribute is a binary.
//   - `TIMESTAMP` - The attribute is a timestamp; it shal not timezone-aware and it's always encoded as a UNIX timestamp number (~UTC).
//   - `TIMESTAMPTZ` - The attribute is a timestamp; it is timezone-aware and it's always encoded as an ISO 8601 string.
type AttributeDefinitionSchemaType string

// DataLinkProtocolSchema The type of the data-link layer.
//   - `IEC_62056_21` - The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
//   - `HDLC` - The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
//   - `COSEM_WRAPPER` - The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
//   - `MODBUS` - The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
//   - `MBUS` - The M-Bus protocol. It shall be used for M-Bus application protocol.
//   - `NOT_APPLICABLE` - The data link protocol is not applicable. It's useful for listening communication type.
type DataLinkProtocolSchema string

// DriverActionAttributeSchema Schema that describes driver action attributes.
type DriverActionAttributeSchema struct {
	// Attributes Schema that describes a list of attributes supported by a driver.
	Attributes *DriverAttributesSchema `json:"attributes,omitempty"`

	// Type The type of action.
	//   * `GET_REGISTER` - The action is to get a billing value, for example, instantaneous values.
	//   * `GET_PERIODICAL_PROFILE` - The action is to get a periodical profile, for example, load-profile.
	//   * `GET_IRREGULAR_PROFILE` - The action is to get a non-periodical profile, for, daily profile or monthly billing registers.
	//   * `GET_EVENTS` - The action is to get an event log.
	//   * `GET_CLOCK` - The action is to get the clock.
	//   * `SYNC_CLOCK` - The action is to synchronize the clock. The action synchronizes the clock in the device. If the force attribute is set, it forcefully sets the clock.
	//   * `GET_RELAY_STATE` - The action is to get the relay state.
	//   * `SET_RELAY_STATE` - The action is to set the relay state.
	//   * `GET_DISCONNECTOR_STATE` - The action is to get the disconnector state.
	//   * `SET_DISCONNECTOR_STATE` - The action is to set the disconnector state.
	//   * `GET_TOU` - The action is to get the time-of-use table.
	//   * `SET_TOU` - The action is to set the time-of-use table.
	//   * `GET_LIMITER` - The action is to get the limiter settings.
	//   * `SET_LIMITER` - The action is to set the limiter settings.
	//   * `RESET_BILLING_PERIOD` - The action is to reset the billing period.
	//   * `FW_UPDATE` - The action is to start a firmware update.
	Type *ActionTypeSchema `json:"type,omitempty"`
}

// DriverAppProtocolRefsSchema The list of application protocol references valid for the datalink template.
type DriverAppProtocolRefsSchema = []ApplicationProtocolSchema

// DriverAppProtocolSchema Schema that describes the application protocol.
type DriverAppProtocolSchema struct {
	// Attributes Schema that describes a list of attributes supported by a driver.
	Attributes *DriverAttributesSchema `json:"attributes,omitempty"`

	// Protocol The type of the application layer.
	//   * `IEC_62056_21` - The IEC 62056-21 (IEC-61107, VDEW) protocol.
	//   * `DLMS_SN` - The DLMS short-name protocol.
	//   * `DLMS_LN` - The DLMS logical-name protocol.
	//   * `SCTM` - The SCTM protocol.
	//   * `LIS200` - The LIS200 protocol.
	//   * `ANSI_C12` - The ANSI C12 protocol.
	//   * `MQTT` - The MQTT protocol.
	//   * `MODBUS` - The Modbus protocol.
	Protocol *ApplicationProtocolSchema `json:"protocol,omitempty"`
}

// DriverAppProtocolsSchema The list of application protocols valid for the datalink template.
type DriverAppProtocolsSchema = []DriverAppProtocolSchema

// DriverAttributesSchema Schema that describes a list of attributes supported by a driver.
type DriverAttributesSchema = []AttributeDefinitionSchema

// DriverCommunicationTemplateSchema Schema that describes the communication template.
type DriverCommunicationTemplateSchema struct {
	// AppProtocolTemplates The list of application protocols valid for the datalink template.
	AppProtocolTemplates *DriverAppProtocolsSchema `json:"appProtocolTemplates,omitempty"`

	// DatalinkTemplates The list of datalink templates valid for the communication template.
	DatalinkTemplates *DriverDatalinkTemplateSchemas `json:"datalinkTemplates,omitempty"`

	// Type The type of the communication template.
	Type *string `json:"type,omitempty"`
}

// DriverDatalinkTemplateSchema Schema that describes the datalink template.
type DriverDatalinkTemplateSchema struct {
	// AppProtocolRefs The list of application protocol references valid for the datalink template.
	AppProtocolRefs DriverAppProtocolRefsSchema `json:"appProtocolRefs"`

	// Attributes Schema that describes a list of attributes supported by a driver.
	Attributes DriverAttributesSchema `json:"attributes"`

	// LinkProtocol The type of the data-link layer.
	//   * `IEC_62056_21` - The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
	//   * `HDLC` - The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
	//   * `COSEM_WRAPPER` - The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
	//   * `MODBUS` - The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
	//   * `MBUS` - The M-Bus protocol. It shall be used for M-Bus application protocol.
	//   * `NOT_APPLICABLE` - The data link protocol is not applicable. It's useful for listening communication type.
	LinkProtocol DataLinkProtocolSchema `json:"linkProtocol"`
}

// DriverDatalinkTemplateSchemas The list of datalink templates valid for the communication template.
type DriverDatalinkTemplateSchemas = []DriverDatalinkTemplateSchema

// DriverSchema Schema that describes communication driver details.
type DriverSchema struct {
	// Spec Schema containing communication driver spec.
	Spec *DriverSpecSchema `json:"spec,omitempty"`
}

// DriverSpecSchema Schema containing communication driver spec.
type DriverSpecSchema struct {
	// DriverType The driver type identifier.
	DriverType string `json:"driverType"`

	// Version The version of the driver.
	Version string `json:"version"`
}

// GenericObject defines model for GenericObject.
type GenericObject = interface{}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/6xZfXPbthn/Kjhsd2tXSpadS9Zpt7vJEuvyphdPpJOlXU6FSMjCAgIcANpVc9ln3z3g",
	"u0jKUpa/RALPyw/PO6hPOJRxIgUVRuPxJ6zDPY2JfZyEhkkRHBLq20VYi6gOFUtgA49xsKfIHBKK5A4R",
	"Sz38l0Doj+iXOzfYrN07zw/c9S9ogIAyo0BMIyPRIzWIoC3jnIlH9ER4Sh20kwrRX0mccOogJrQhwhBB",
	"ZaozCl0Xf++uvdXMm07mm/v16gdv7p5QlFDFZMRCwlGi5I7xY21ckmiQb9W1eOu1e/cwn6zPUCKkGPQo",
	"clBEGD8Ua0gqFEth9vxQ2kDRR6YNVY1Dum/dZeD36xSIPlFhEJePdbbpfDX9ey+X2VMUchl+LFj898vp",
	"CR59EOFeScF+ozXeOl2NQlckiAn7EtEnFtIh8nb2dSdVSBExRrFtaigo0dQ4iJlsa5dyfoAl3UaaxdV8",
	"8n7jB5PAPXlERTk5IG2IKT3qn8Gu+9lB+8zzp6vl0p0Gq/UZICKmQykEDY1UbSxnCtMvCgNkwerhJBTD",
	"YjqQu0GqKTJkyxtI+pj1S8ygee4tvFOJDgI4i5mhCgQaJh51Xfkpfv0C/9oFCbfefO4t7/Ki0ClI0UJU",
	"kXFZrhaCfni3ebif9brAEAU5vmMqfiaKojSJMvtjB1ORxnj8M65XPezg7iqVb7QKS76eZXz+YnMSO7hK",
	"0HyjFsSw3VrpjtSctHMjj6CcJHuq+TZfr9667I4dXFoRf3Aw9AY8xtooJh7xZwdPkoSzkIBd75U0MpT8",
	"nN4CTiMVK+LkQFXhN8+dbt7cjF6/2dxcF67z3Cmya4Oba/SN504Hb66vR39y0NuZ++5bqMJWdyFiNl/4",
	"G39ZcMMr0nupzECQmHaTz5vkXD5C0e9m8KfBoqCG5xbB3PNvRqOCJHtrEU2WvreZXt8UZPCOptc3LcLF",
	"P4KgIILnNsFqdvtQdpWFjLaprhPVQrpuXezg3FLF0xye4ETYwRlq7OACJ3YwaIcfq687Ioo2MKM7Jhi4",
	"ty8isnVk9sSgbGdLNSIoUuyJqqqh5AfIOnsmZkdSbt7CCIHHeDQYja+H3w9Hw5vXr7HTEXdFK87r1xA7",
	"OCYiIkaqAx4blVIHg6PxGBekuDybH6y95R2cLVEyocowqtsoPuHfK7rDY/y7q2oAu8qnr6s7Kqhi4Wr7",
	"bxoaENXA2JUqtZUyY5oGaZm+dqRjiZ6AEcZQjZ731OzBEvujll1ywywjpGko2UrJKRGgJbNTF2SbKmdi",
	"zRZerBE1KVniWV+UBb2On6BMellGloF7V+tBDVqBmDD0sSo6y4fFbR8ximjIYsKRSONtxXK7Ws3dybKH",
	"J7dYSewtJ+v3fbRMEHUoSANv4frBZHHfQw2dWxsSJ3+BCUvvAZg0dvk3KeiA2HZGRISY+YNGhD+Tg0ZU",
	"hDKiESIg4mHp/bOSk58LffPfh2D6bQtG8NNZQKCtng9BIM9foe/fjK4rt9WqVJ5zDs69iB2ceQg7OLc7",
	"PFmjYgeXWOvPwU8dBaoMPSzLXJwRQ+ZMfLy0g0XEkAFn4uPL/QvalO1bZRdzUNnFav0LeQKFMoaAsJn/",
	"zMw+60cFSaY5q5C2vtqstnO1jONUFC11e7BNE3ygn5kJ99SOPUAYy4git3j7cTafftdQMUR+miRSGY1I",
	"FCmqNQxXf0Vxyg1LeDH/aySz64CGvOdMlFkKIouTwzP6xvNXV3DeV69Gf/4W7RSJweXIMygkAm0pSjWN",
	"7AXuiSgG98P6eFAA0w7SabiHALKApUJZJ6ohDjmjwlxpqmwP+SL805XvLjbv1pP7+6om2EX0rEiSUNUJ",
	"3WLqwv2V4Z3u9oAMigJvYMuputBBS1AUCYmk7QwQ1qgK68rm4EoH8hyklmDqUAa3ZyCxRJ1mKmrxKthM",
	"7u/n3nRyW93PK1glcKZt5ctlwR0GeVBvUg13TquNQzMXYOBmekAenxyM4LDYwY1QqCYfBy+ynybWzolo",
	"ZpM1+/hSTkeXzUTFRJRdYMoyrFuTUbWFxz9fOCitiyFp8t2J+chuHk9GnZpuztA0aGraEa5rqgZtVZWB",
	"G3ez1nBWN8Tp0Sx3T0mfe6Y2o5zibn1T6+4wmY4kKVrMmu70qTYDYWs/wnXlq6I7qqiAEvFEOMvSqmhI",
	"NkMMjRNe3maZofGLZui/yVUHIkqRQ+d5Lgvn4+tf86by9R1ZyP8/bHCWV7/YpV/TkX2+6XfjscXOvqiV",
	"RyolIJ01OhrBAFJc5Y7K1KWFyZdxdYX7srvbh3OzoPf22mu+ab2vBLm/Ls+Ho/bU8PtRRlSuLdRdHhS1",
	"7CiC7UJhsyM2P/+j4ezL3akTnzO1n0BxieF7cq3X5lC6LzZ3rd5/dr5KTeO1C8uLUrovOGBWRf+TMkUj",
	"mIAaIhsonZYBPlzoEX26KLaccFwRTwXLBWWxJ1x6k/uycGqCzIe2iBrCeHtU0wkNrWBLFmTqp+9v1yt/",
	"Prn1N4vJnbtwA3e9gXsFdvATVTrT/nQ9vBm+sv5rhmkh82VD+AkNX+5tNao+E4RSGMI6Juz8+ACp/QHv",
	"y8/c+gpXE9X5HS2DYQsPi6gwbMeKjtQa1Ut1XZLyzfL2X2tt7XJVz6saxEpFVwI1vxKOP30GSUzsJACy",
	"hrbLmMaEcTy2W38LD1slNSdbPQxljMtmOLXraE62GhlKYCdVwLU3JtHjq6vn5+dhk/mKiYj+OqBiuDcx",
	"b32mxNDqpECTe89+Q+DapucqoeJHF7zFWUiFto7IQdz688H1cNTSLRMqtExVSIdSPV7ljPqqoIeQZIbT",
	"M5RWITIa5qwgnSQMj/Gr4Wj4Cqo5MXuNxyLl/PP/AgAA//9v4cXvIh8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../openhes/driver/driverdata/driverdata.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
