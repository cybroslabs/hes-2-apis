// Package driver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package driver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/cybroslabs/hes-2-apis/openapi/k8s/containers"
	externalRef1 "github.com/cybroslabs/hes-2-apis/openapi/openhes/driver/driverdata"
	externalRef2 "github.com/cybroslabs/hes-2-apis/openapi/openhes/job"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for AttributeDefinitionSchemaType.
const (
	BINARY  AttributeDefinitionSchemaType = "BINARY"
	BOOLEAN AttributeDefinitionSchemaType = "BOOLEAN"
	INTEGER AttributeDefinitionSchemaType = "INTEGER"
	NUMBER  AttributeDefinitionSchemaType = "NUMBER"
	STRING  AttributeDefinitionSchemaType = "STRING"
)

// AttributeDefinitionSchema Schema that describes a driver attribute.
type AttributeDefinitionSchema struct {
	DefaultValue *GenericObject `json:"defaultValue,omitempty"`

	// Description The description of the attribute.
	Description *string `json:"description,omitempty"`

	// Mandatory Indicates whether the attribute is mandatory or not.
	Mandatory *bool `json:"mandatory,omitempty"`

	// Name The name of the attribute.
	Name *string `json:"name,omitempty"`

	// Type The type of the attribute.
	//   * `STRING` - The attribute is a string.
	//   * `INTEGER` - The attribute is an integer.
	//   * `NUMBER` - The attribute is a decimal number.
	//   * `BOOLEAN` - The attribute is a boolean.
	//   * `BINARY` - The attribute is a binary.
	Type *AttributeDefinitionSchemaType `json:"type,omitempty"`
}

// AttributeDefinitionSchemaType The type of the attribute.
//   - `STRING` - The attribute is a string.
//   - `INTEGER` - The attribute is an integer.
//   - `NUMBER` - The attribute is a decimal number.
//   - `BOOLEAN` - The attribute is a boolean.
//   - `BINARY` - The attribute is a binary.
type AttributeDefinitionSchemaType string

// DriverActionAttributeSchema Schema that describes driver action attributes.
type DriverActionAttributeSchema struct {
	// Attributes Schema that describes a list of attributes supported by a driver.
	Attributes *DriverAttributesSchema `json:"attributes,omitempty"`

	// Type The type of action.
	//   * `GET_REGISTER` - The action is to get a billing value, for example, instantaneous values.
	//   * `GET_PERIODICAL_PROFILE` - The action is to get a periodical profile, for example, load-profile.
	//   * `GET_IRREGULAR_PROFILE` - The action is to get a non-periodical profile, for, daily profile or monthly billing registers.
	//   * `GET_EVENTS` - The action is to get an event log.
	//   * `GET_CLOCK` - The action is to get the clock.
	//   * `SYNC_CLOCK` - The action is to synchronize the clock. The action synchronizes the clock in the device. If the force attribute is set, it forcefully sets the clock.
	//   * `GET_RELAY_STATE` - The action is to get the relay state.
	//   * `SET_RELAY_STATE` - The action is to set the relay state.
	//   * `GET_DISCONNECTOR_STATE` - The action is to get the disconnector state.
	//   * `SET_DISCONNECTOR_STATE` - The action is to set the disconnector state.
	//   * `GET_TOU` - The action is to get the time-of-use table.
	//   * `SET_TOU` - The action is to set the time-of-use table.
	//   * `GET_LIMITER` - The action is to get the limiter settings.
	//   * `SET_LIMITER` - The action is to set the limiter settings.
	//   * `RESET_BILLING_PERIOD` - The action is to reset the billing period.
	//   * `FW_UPDATE` - The action is to start a firmware update.
	Type *externalRef2.ActionTypeSchema `json:"type,omitempty"`
}

// DriverAppProtocolSchema Schema that describes the application protocol.
type DriverAppProtocolSchema struct {
	// Profile Schema that describes a list of attributes supported by a driver.
	Profile *DriverAttributesSchema `json:"profile,omitempty"`

	// Protocol The application protocol.
	Protocol *string `json:"protocol,omitempty"`
}

// DriverAppProtocolsSchema The list of application protocols valid for the datalink template.
type DriverAppProtocolsSchema = []DriverAppProtocolSchema

// DriverAttributesSchema Schema that describes a list of attributes supported by a driver.
type DriverAttributesSchema = []AttributeDefinitionSchema

// DriverCommunicationTemplateSchema Schema that describes the communication template.
type DriverCommunicationTemplateSchema struct {
	// DatalinkTemplates The list of datalink templates valid for the communication template.
	DatalinkTemplates *DriverDatalinkTemplateSchemas `json:"datalinkTemplates,omitempty"`

	// Type The type of the communication template.
	Type *string `json:"type,omitempty"`
}

// DriverDatalinkTemplateSchema Schema that describes the datalink template.
type DriverDatalinkTemplateSchema struct {
	// AppProtocols The list of application protocols valid for the datalink template.
	AppProtocols *DriverAppProtocolsSchema `json:"appProtocols,omitempty"`

	// LinkProtocol The link protocol.
	LinkProtocol *string `json:"linkProtocol,omitempty"`
}

// DriverDatalinkTemplateSchemas The list of datalink templates valid for the communication template.
type DriverDatalinkTemplateSchemas = []DriverDatalinkTemplateSchema

// DriverDetailsSchema defines model for DriverDetailsSchema.
type DriverDetailsSchema struct {
	// Spec Schema that registers new or updates already registered communication drivers.
	Spec *DriverSpecSchema `json:"spec,omitempty"`

	// Status Schema that describes the status of a driver.
	Status *DriverStatusSchema `json:"status,omitempty"`
}

// DriverSchema Schema that describes communication driver details.
type DriverSchema struct {
	// Spec Schema that registers new or updates already registered communication drivers.
	Spec *DriverSpecSchema `json:"spec,omitempty"`
}

// DriverSpecSchema Schema that registers new or updates already registered communication drivers.
type DriverSpecSchema struct {
	Image string `json:"image"`

	// ImagePullSecrets Schema that describes the image pull secrets for the driver.
	ImagePullSecrets *ImagePullSecretsSchema `json:"imagePullSecrets,omitempty"`

	// Resources Resource values for a container.
	Resources externalRef0.ContainerResourcesSetSchema `json:"resources"`
}

// DriverStatusSchema Schema that describes the status of a driver.
type DriverStatusSchema struct {
	DriverType string `json:"driverType"`
}

// GenericObject defines model for GenericObject.
type GenericObject = interface{}

// ImagePullSecretsSchema Schema that describes the image pull secrets for the driver.
type ImagePullSecretsSchema = []string

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9xabXMaOfL/Kir9U5XdZBiws8k/4c0uxqyPWgwuIHuV83GsmGlAGz3MSRo7rM/f/Urz",
	"DMyMByd5cy9SHqRWd+vXj5LygD3JAylAGI27D1h7W+Ak+uwZo+gqNHAJayqooVLMolk76YP2FA3sIO7i",
	"eByZLTEonlmBRgT5it6BQiTl5P5TYAfDF8IDBjGbNQmZ+Z2wEHAXd1qd7pn73u2452/fYudAynwLSMGG",
	"agMKGYk2YFzsYE6ET4xUO9w1KgQHC8Its5QUO9jsAjsym0+H4yv86OBAyQCUoaCPtXjALxSscRf/XzvH",
	"pp0A074CAYp6k9Wf4BnLak/HhxKVCyNIrpHZwiEgiXraKCo2lmdhS4cch8KnHjGg0f0WzNYiUWSIqEbZ",
	"aiQVEtLsCVlJyYAIKyXGqUxlO9NU13igjIudKeOC0Cv0R2yLP1ALzQ/1JyjmnpIOx/PB1WBaTisQFQY2",
	"oFLq8cfriypi5INHOWFIhHyVL7mYTEaD3rhiTYJYRjwc96afqmipIGqXuLkIOe7epl7n4GQf2MGxjtjB",
	"iWT7FbHFiyOEM4ixzHzuMoqrnmfBzsL0tOBMQzPikW9DH4VoPoW7tydG7DSN1t7rmkCNJg9DtFTSeQNJ",
	"rX1Ja8J0QVTrWFQO+dVgvpwOroaz+WB6nCWKQNTniMQ8GX1imUKw1K2WAQgS0KX9uwW9/FOuon+xuee7",
	"ILV0nWsEwY2SRnqSneYWUawGAbM5xjpGkHCJ3WIfkEDJNWXwfDRS5uXpo1qN5hGSw6CrcLCiGNXGZqoy",
	"kRrdEUZ9tJZxqvWJIYyKz8gADxhJ8yI1wJs6xpFx8h0QpciusIFD1BqX3mxLGQekwyCQyoCPVrusOB/E",
	"+6kRPpM8L8rPq8aLhuBV9yOV8PUl56FILDpP7HV6QHhFNgd2P+gkEudIZTX0iMuDZbOkC2tcXus0bBwt",
	"5VqcAlRFbBzk0UJQnhwwhexhBd3UZpBIlWemjiqT1OaPo/0fJo86O52QQSosVRkHl2AILaZAwthkHUX7",
	"08Iy5g8HhtSGmLChxrOItrpwLZxGTraPX9LD+PHujjoXHYBn/1JONlaWL73PoNyEwvUkbyff7ZhT29ut",
	"lNSMrHTLruFgQLV8xnX37gw7WIGWofLi3TPKaXxm8oIQd88czIFHeQ+fv313TS36Cv4dgi5Q4bNOh+MC",
	"6bufLKUFJEczVmYeA9T/dDGdzEa9i9nyunc1uB7MB9Pl5eh6Vue8p0Xu/yyoRy1cqnwDfw3Ae7rNKlDV",
	"Yp0WP40E3NtTWRj4UXYgTAHxdxkB+KXWODbDN4M/YnQTMjYDT4FF9Rbz3VJHv5ZR8V58Z8/ft1Gys4d8",
	"t1+5SfSDBVxTsUE+3YA26Be9Jedv33XPzt/89Pbd/7//0CErz4f1j7ZWEWNAWQP+65a0/uq1/tFpfWi5",
	"i9c/dG87rQ+L1z/+nI+3o+GcbPH6PylvS0xaa0tfdmo+hr3eK4cH9HnG3zNNk3PF5/d66UlhCBWg9j77",
	"6ec05TkDU4gCa1SqwLc+EpupKH5RHSbF5H9COxGnxKiLLe9Wm+fKo0atsK7oatUsylxjkdt+uXiV/1i8",
	"KG01ivgVFCgDbv+aqfvw6OAKFzgBz8hmKAgZQ3F86/xUU4A3a0Qq7nry7uI5LtUPwnHIq5Tv33xEqUvZ",
	"3ikERAUSIbdoWG25i6YQKNDWt5N7HOshnlSgHZtbOWWMRj8RjbvjhI89Aa3X9Av46J6aLXrJX7pFbzpz",
	"sBVADO7iNZPE2HRFBeUhx92O2+mcZQjEcr8CgplRp0EQG+E7I5Am6aKnn7U+LKLM94r//KIslT0Hgeuo",
	"ClQhEM8egOBG920VGyEoFDRqwTkQHSrgIIyDdOhtEdHo5TV9Gbk6hxVd7Qzo/W3HZatq37e/XV/Nbxb0",
	"m+2+zvJE+IiX7X9f5aqqmhXg/XQXET9gKaBB2//VLm2PCt9BQJ42HheP+Z6/vaw97zxM3BbKTHhZ6v66",
	"OnvkFNN9L4jcmKCMW8Er4gvamu7s7Kphb5Z4kbXjATt8jhswLGkJ7Qlv3ydzzt+8ayk0R7lm30vKgX8k",
	"26rzjCdvdmvve+Ir+/Q5onhnnT1KxJf6VCevZNHDBGO2fkRO5EROlHiNg6jQhghDBMhQp8mmwP5mMB1O",
	"Lof93mh5M538OhwNagQFoKj0qUcYSu6HD6QxSfxWMlWUMpxOB1cfR71pAyFCilaFIAf5hLJdOhaVQynM",
	"lu0yDLLTWFH84PfBeD6rlikQ3IEwiMlNcVl/NOn/VrkquvJh0vucvXp9Gvdr1uid8LZKCvoXFNYW6QoU",
	"OiexDULUxcEd9cBFw7jqr6XNG3tPVBqMg6iJp9YhYzs7pI81jf1q1Pu0nM1780HtFhUwsou69fx5r8Fy",
	"Xb3cSr8czvqT8XjQn0+mDZTwqfakEOAZqY51achMP8nMajaffKxVxVAOLbluhRqQISu2p0nVYv3UYit5",
	"NLwe1gW6iS4jOTWgLENDxUYXhdet10+snw4sh4vhaDQcXyVJoZSRbU1jVmnExbGaMvr178uPN5eVJjBE",
	"2RhfU8XviYLkrmT/TXXvpc7B5VkqmThKLMl4HPHJjygmsYPzAE0mCk5sp49Gyj01IS2dSDwoIYm/CrZN",
	"xvNfZbhjB2colr0ZPzqYirWMCrItXNEZEgMnlOFuNPVLfmXietJW/+Shph+NoxFZaWSA2JlQ2VVbYwLd",
	"bbfv7+/d/cVtKnz40gLhbg1nR/8pAvcl51Kg3s0QcekDi5uYSQDibwNrAEY9EDrqahMlLmaj1pnbOZJt",
	"K2dcfl2pNu1koW6n9PaMSk18kn9C6B0oHavXcZOlSX3GXfzG7bhv4gPBVuOuCBl7/G8AAAD//24K3Lsr",
	"IwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../k8s/containers/containers.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../openhes/driver/driverdata/driverdata.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(path.Dir(pathToFile), "../job/job.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
