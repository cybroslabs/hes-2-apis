// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file pbdriver-models.proto (package io.clbs.openhes.pbdriver, edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Empty, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file pbdriver-models.proto.
 */
export const file_pbdriver_models: GenFile = /*@__PURE__*/
  fileDesc("ChVwYmRyaXZlci1tb2RlbHMucHJvdG8SGGlvLmNsYnMub3Blbmhlcy5wYmRyaXZlciKaAQoOUHJvZ3Jlc3NVcGRhdGUSOgoDam9iGAEgASgLMisuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkpvYlByb2dyZXNzVXBkYXRlSAASQAoGYWN0aW9uGAIgASgLMi4uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkFjdGlvblByb2dyZXNzVXBkYXRlSABCCgoIcHJvZ3Jlc3MipwEKFEFjdGlvblByb2dyZXNzVXBkYXRlEg4KBmpvYl9pZBgBIAEoCRIRCglhY3Rpb25faWQYAiABKAkSOAoEY29kZRgDIAEoDjIqLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BY3Rpb25SZXN1bHRDb2RlEjIKBGRhdGEYBCABKAsyJC5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uRGF0YSJrChFKb2JQcm9ncmVzc1VwZGF0ZRIOCgZqb2JfaWQYASABKAkSNAoEY29kZRgCIAEoDjImLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Kb2JFcnJvckNvZGUSEAoIZHVyYXRpb24YAyABKAMitwEKCkFjdGlvbkRhdGESKAoGbm9kYXRhGAEgASgLMhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5SAASOwoIYmlsbGluZ3MYAiABKAsyJy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQmlsbGluZ1ZhbHVlc0gAEjoKB3Byb2ZpbGUYAyABKAsyJy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuUHJvZmlsZVZhbHVlc0gAQgYKBGRhdGEiZAoNUHJvZmlsZVZhbHVlcxIOCgZwZXJpb2QYASABKAUSDAoEdW5pdBgCIAEoCRI1CgZibG9ja3MYAyADKAsyJS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuUHJvZmlsZUJsb2siewoLUHJvZmlsZUJsb2sSMwoPc3RhcnRfdGltZXN0YW1wGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI3CgZ2YWx1ZXMYAiADKAsyJy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuTWVhc3VyZWRWYWx1ZSJHCg1CaWxsaW5nVmFsdWVzEjYKBnZhbHVlcxgBIAMoCzImLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5CaWxsaW5nVmFsdWUigwEKDEJpbGxpbmdWYWx1ZRItCgl0aW1lc3RhbXAYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEgwKBHVuaXQYAiABKAkSNgoFdmFsdWUYAyABKAsyJy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuTWVhc3VyZWRWYWx1ZSLnAQoNTWVhc3VyZWRWYWx1ZRIOCgZzdGF0dXMYASABKAMSEAoIZXhwb25lbnQYAiABKAUSFgoMZG91YmxlX3ZhbHVlGAMgASgBSAASEwoJaW50X3ZhbHVlGAQgASgDSAASEwoJc3RyX3ZhbHVlGAUgASgJSAASNQoPdGltZXN0YW1wX3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAEhwKEnRpbWVzdGFtcF90el92YWx1ZRgHIAEoCUgAEhQKCmJvb2xfdmFsdWUYCCABKAhIAEIHCgV2YWx1ZSLAAgoTQXR0cmlidXRlRGVmaW5pdGlvbhIMCgRuYW1lGAEgASgJEhMKC2Rlc2NyaXB0aW9uGAIgASgJEjUKBHR5cGUYAyABKA4yJy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQXR0cmlidXRlVHlwZRIRCgltYW5kYXRvcnkYBCABKAgSPwoNZGVmYXVsdF92YWx1ZRgFIAEoCzIoLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BdHRyaWJ1dGVWYWx1ZRJLCgdvcHRpb25zGAYgAygLMjouaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkF0dHJpYnV0ZURlZmluaXRpb24uT3B0aW9uc0VudHJ5Gi4KDE9wdGlvbnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIowBChNKb2JBY3Rpb25BdHRyaWJ1dGVzEjIKBHR5cGUYASABKA4yJC5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uVHlwZRJBCgphdHRyaWJ1dGVzGAIgAygLMi0uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkF0dHJpYnV0ZURlZmluaXRpb24iiwEKEFN0YXJ0Sm9ic1JlcXVlc3QSQQoPY29ubmVjdGlvbl9pbmZvGAIgASgLMiguaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkNvbm5lY3Rpb25JbmZvEjQKBGpvYnMYASADKAsyJi5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuU3RhcnRKb2JEYXRhIqgDCgxTdGFydEpvYkRhdGESVwoRZGV2aWNlX2F0dHJpYnV0ZXMYASADKAsyPC5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuU3RhcnRKb2JEYXRhLkRldmljZUF0dHJpYnV0ZXNFbnRyeRIOCgZqb2JfaWQYAiABKAkSOwoMam9iX3NldHRpbmdzGAMgASgLMiUuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkpvYlNldHRpbmdzEjgKC2pvYl9hY3Rpb25zGAQgAygLMiMuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkpvYkFjdGlvbhJDCgxhcHBfcHJvdG9jb2wYBSABKA4yLS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQXBwbGljYXRpb25Qcm90b2NvbBIQCgh0aW1lem9uZRgGIAEoCRphChVEZXZpY2VBdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEjcKBXZhbHVlGAIgASgLMiguaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkF0dHJpYnV0ZVZhbHVlOgI4ASK5AQoeQ29ubmVjdGlvblR5cGVDb250cm9sbGVkU2VyaWFsEkYKBmRpcmVjdBgBIAEoCzI0LmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Db25uZWN0aW9uVHlwZVNlcmlhbERpcmVjdEgAEkIKBG1veGEYAiABKAsyMi5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQ29ubmVjdGlvblR5cGVTZXJpYWxNb3hhSABCCwoJY29udmVydGVyIpQCCglNb2RlbUluZm8SCgoCaWQYASABKAkSDAoEbmFtZRgCIAEoCRIPCgdhdF9pbml0GAMgASgJEg8KB2F0X3Rlc3QYBCABKAkSEQoJYXRfY29uZmlnGAUgASgJEg8KB2F0X2RpYWwYBiABKAkSEQoJYXRfaGFuZ3VwGAcgASgJEhEKCWF0X2VzY2FwZRgIIAEoCRIOCgZhdF9kc3IYCSABKAgSFwoPY29ubmVjdF90aW1lb3V0GAogASgNEkQKBXRjcGlwGAsgASgLMjMuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkNvbm5lY3Rpb25UeXBlRGlyZWN0VGNwSXBIAEISChBtb2RlbV9jb25uZWN0aW9uIpUCCgxTZXJpYWxDb25maWcSQQoJYmF1ZF9yYXRlGAEgASgOMi4uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLlNlcmlhbENvbmZpZ0JhdWRSYXRlEjwKBnBhcml0eRgCIAEoDjIsLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5TZXJpYWxDb25maWdQYXJpdHkSQQoJZGF0YV9iaXRzGAMgASgOMi4uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLlNlcmlhbENvbmZpZ0RhdGFCaXRzEkEKCXN0b3BfYml0cxgEIAEoDjIuLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5TZXJpYWxDb25maWdTdG9wQml0cyLgAgoOQ29ubmVjdGlvbkluZm8SRAoFdGNwaXAYASABKAsyMy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQ29ubmVjdGlvblR5cGVEaXJlY3RUY3BJcEgAEkcKCm1vZGVtX3Bvb2wYAiABKAsyMS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQ29ubmVjdGlvblR5cGVNb2RlbVBvb2xIABJSCg5zZXJpYWxfb3Zlcl9pcBgDIAEoCzI4LmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Db25uZWN0aW9uVHlwZUNvbnRyb2xsZWRTZXJpYWxIABJBCg1saW5rX3Byb3RvY29sGAQgASgOMiouaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkRhdGFMaW5rUHJvdG9jb2wSGgoSY3VzdG9tX2dyb3VwaW5nX2lkGAUgASgJQgwKCmNvbm5lY3Rpb24iSAoZQ29ubmVjdGlvblR5cGVEaXJlY3RUY3BJcBIMCgRob3N0GAEgASgJEgwKBHBvcnQYAiABKA0SDwoHdGltZW91dBgDIAEoBSJuChdDb25uZWN0aW9uVHlwZU1vZGVtUG9vbBIOCgZudW1iZXIYASABKAkSDwoHcG9vbF9pZBgCIAEoCRIyCgVtb2RlbRgEIAEoCzIjLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Nb2RlbUluZm8iOAoaQ29ubmVjdGlvblR5cGVTZXJpYWxEaXJlY3QSDAoEaG9zdBgBIAEoCRIMCgRwb3J0GAIgASgNIk8KGENvbm5lY3Rpb25UeXBlU2VyaWFsTW94YRIMCgRob3N0GAEgASgJEhAKCGRhdGFQb3J0GAIgASgNEhMKC2NvbW1hbmRQb3J0GAMgASgNIsgBCgtKb2JTZXR0aW5ncxIUCgxtYXhfZHVyYXRpb24YASABKAMSNwoIcHJpb3JpdHkYAiABKA4yJS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuSm9iUHJpb3JpdHkSEAoIYXR0ZW1wdHMYAyADKAUSEwoLcmV0cnlfZGVsYXkYBCABKAMSEwoLZGVmZXJfc3RhcnQYBSABKAQSLgoKZXhwaXJlc19hdBgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAi1QoKCUpvYkFjdGlvbhIRCglhY3Rpb25faWQYASABKAkSRwoKYXR0cmlidXRlcxgCIAMoCzIzLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Kb2JBY3Rpb24uQXR0cmlidXRlc0VudHJ5EkMKDGdldF9yZWdpc3RlchgDIAEoCzIrLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BY3Rpb25HZXRSZWdpc3RlckgAElYKFmdldF9wZXJpb2RpY2FsX3Byb2ZpbGUYBCABKAsyNC5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uR2V0UGVyaW9kaWNhbFByb2ZpbGVIABJUChVnZXRfaXJyZWd1bGFyX3Byb2ZpbGUYBSABKAsyMy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uR2V0SXJyZWd1bGFyUHJvZmlsZUgAEj8KCmdldF9ldmVudHMYBiABKAsyKS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uR2V0RXZlbnRzSAASPQoJZ2V0X2Nsb2NrGAcgASgLMiguaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkFjdGlvbkdldENsb2NrSAASPwoKc3luY19jbG9jaxgIIAEoCzIpLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BY3Rpb25TeW5jQ2xvY2tIABJICg9nZXRfcmVsYXlfc3RhdGUYCSABKAsyLS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uR2V0UmVsYXlTdGF0ZUgAEkgKD3NldF9yZWxheV9zdGF0ZRgKIAEoCzItLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BY3Rpb25TZXRSZWxheVN0YXRlSAASVgoWZ2V0X2Rpc2Nvbm5lY3Rvcl9zdGF0ZRgLIAEoCzI0LmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BY3Rpb25HZXREaXNjb25uZWN0b3JTdGF0ZUgAElYKFnNldF9kaXNjb25uZWN0b3Jfc3RhdGUYDCABKAsyNC5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uU2V0RGlzY29ubmVjdG9yU3RhdGVIABI5CgdnZXRfdG91GA0gASgLMiYuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkFjdGlvbkdldFRvdUgAEjkKB3NldF90b3UYDiABKAsyJi5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uU2V0VG91SAASQQoLZ2V0X2xpbWl0ZXIYDyABKAsyKi5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uR2V0TGltaXRlckgAEkEKC3NldF9saW1pdGVyGBAgASgLMiouaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkFjdGlvblNldExpbWl0ZXJIABJSChRyZXNldF9iaWxsaW5nX3BlcmlvZBgRIAEoCzIyLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BY3Rpb25SZXNldEJpbGxpbmdQZXJpb2RIABI9Cglmd191cGRhdGUYEiABKAsyKC5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQWN0aW9uRndVcGRhdGVIABpbCg9BdHRyaWJ1dGVzRW50cnkSCwoDa2V5GAEgASgJEjcKBXZhbHVlGAIgASgLMiguaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkF0dHJpYnV0ZVZhbHVlOgI4AUIICgZhY3Rpb24iEwoRQWN0aW9uR2V0UmVnaXN0ZXIibgoaQWN0aW9uR2V0UGVyaW9kaWNhbFByb2ZpbGUSKAoEZnJvbRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASJgoCdG8YAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIm0KGUFjdGlvbkdldElycmVndWxhclByb2ZpbGUSKAoEZnJvbRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASJgoCdG8YAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wImMKD0FjdGlvbkdldEV2ZW50cxIoCgRmcm9tGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBImCgJ0bxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiEAoOQWN0aW9uR2V0Q2xvY2siEQoPQWN0aW9uU3luY0Nsb2NrIhUKE0FjdGlvbkdldFJlbGF5U3RhdGUiFQoTQWN0aW9uU2V0UmVsYXlTdGF0ZSIcChpBY3Rpb25HZXREaXNjb25uZWN0b3JTdGF0ZSIcChpBY3Rpb25TZXREaXNjb25uZWN0b3JTdGF0ZSIOCgxBY3Rpb25HZXRUb3UiDgoMQWN0aW9uU2V0VG91IhIKEEFjdGlvbkdldExpbWl0ZXIiEgoQQWN0aW9uU2V0TGltaXRlciIaChhBY3Rpb25SZXNldEJpbGxpbmdQZXJpb2QiEAoOQWN0aW9uRndVcGRhdGUiiQEKDkF0dHJpYnV0ZVZhbHVlEhMKCXN0cl92YWx1ZRgBIAEoCUgAEhMKCWludF92YWx1ZRgCIAEoA0gAEhYKDGRvdWJsZV92YWx1ZRgDIAEoAUgAEhYKDGJpbmFyeV92YWx1ZRgEIAEoDEgAEhQKCmJvb2xfdmFsdWUYBSABKAhIAEIHCgV2YWx1ZSJFCg5Db21tb25SZXNwb25zZRIzCgZyZXN1bHQYASABKA4yIy5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuRXJyb3JDb2RlIq0BChtBcHBsaWNhdGlvblByb3RvY29sVGVtcGxhdGUSCgoCaWQYASABKAkSPwoIcHJvdG9jb2wYAiABKA4yLS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQXBwbGljYXRpb25Qcm90b2NvbBJBCgphdHRyaWJ1dGVzGAMgAygLMi0uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkF0dHJpYnV0ZURlZmluaXRpb24i4gEKEERhdGFMaW5rVGVtcGxhdGUSQQoNbGlua19wcm90b2NvbBgBIAEoDjIqLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5EYXRhTGlua1Byb3RvY29sEkgKEWFwcF9wcm90b2NvbF9yZWZzGAIgAygOMi0uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkFwcGxpY2F0aW9uUHJvdG9jb2wSQQoKYXR0cmlidXRlcxgDIAMoCzItLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BdHRyaWJ1dGVEZWZpbml0aW9uIpEBChVDb21tdW5pY2F0aW9uVGVtcGxhdGUSOQoEdHlwZRgBIAEoDjIrLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Db21tdW5pY2F0aW9uVHlwZRI9CglkYXRhbGlua3MYAiADKAsyKi5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuRGF0YUxpbmtUZW1wbGF0ZSIvChNBY2Nlc3NMZXZlbFRlbXBsYXRlEgoKAmlkGAEgASgJEgwKBG5hbWUYAiABKAkijwMKD0RyaXZlclRlbXBsYXRlcxJQChdjb21tdW5pY2F0aW9uX3RlbXBsYXRlcxgBIAMoCzIvLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Db21tdW5pY2F0aW9uVGVtcGxhdGUSTAoNYXBwX3Byb3RvY29scxgCIAMoCzI1LmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BcHBsaWNhdGlvblByb3RvY29sVGVtcGxhdGUSSAoRYWN0aW9uX2F0dHJpYnV0ZXMYAyADKAsyLS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuSm9iQWN0aW9uQXR0cmlidXRlcxJHChBhY2Nlc3NfdGVtcGxhdGVzGAQgAygLMi0uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkFjY2Vzc0xldmVsVGVtcGxhdGUSSQoSYWN0aW9uX2NvbnN0cmFpbnRzGAUgASgLMi0uaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkpvYkFjdGlvbkNvbnRyYWludHMiGwoKU3RyaW5nTGlzdBINCgVpdGVtcxgBIAMoCSKVAwoTSm9iQWN0aW9uQ29udHJhaW50cxJmChZnZXRfcmVnaXN0ZXJfdHlwZV9uYW1lGAEgAygLMkYuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkpvYkFjdGlvbkNvbnRyYWludHMuR2V0UmVnaXN0ZXJUeXBlTmFtZUVudHJ5EnIKHGdldF9yZWdpc3Rlcl90eXBlX2F0dHJpYnV0ZXMYAiADKAsyTC5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuSm9iQWN0aW9uQ29udHJhaW50cy5HZXRSZWdpc3RlclR5cGVBdHRyaWJ1dGVzRW50cnkaOgoYR2V0UmVnaXN0ZXJUeXBlTmFtZUVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaZgoeR2V0UmVnaXN0ZXJUeXBlQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRIzCgV2YWx1ZRgCIAEoCzIkLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5TdHJpbmdMaXN0OgI4ASIiChBDYW5jZWxKb2JSZXF1ZXN0Eg4KBmpvYl9pZBgBIAEoCSL3AQoQTmVnb3RpYXRlUmVxdWVzdBIPCgd2ZXJzaW9uGAEgASgJEhYKDmxpc3RlbmluZ19wb3J0GAIgASgNEhMKC2RyaXZlcl90eXBlGAMgASgJEhsKE21heF9jb25jdXJyZW50X2pvYnMYBCABKAUSGQoRbWF4X2Nhc2NhZGVfZGVwdGgYBSABKA0SGQoRdHlwaWNhbF9tZW1fdXNhZ2UYBiABKAUSPAoJdGVtcGxhdGVzGAcgASgLMikuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLkRyaXZlclRlbXBsYXRlcxIUCgxkaXNwbGF5X25hbWUYCCABKAki5QIKFERldmljZUNvbm5lY3Rpb25JbmZvEkQKEmNvbW11bmljYXRpb25fdW5pdBgBIAEoCzIoLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5Db25uZWN0aW9uSW5mbxJDCgxhcHBfcHJvdG9jb2wYAiABKA4yLS5pby5jbGJzLm9wZW5oZXMucGJkcml2ZXIuQXBwbGljYXRpb25Qcm90b2NvbBJfChFkZXZpY2VfYXR0cmlidXRlcxgDIAMoCzJELmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5EZXZpY2VDb25uZWN0aW9uSW5mby5EZXZpY2VBdHRyaWJ1dGVzRW50cnkaYQoVRGV2aWNlQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRI3CgV2YWx1ZRgCIAEoCzIoLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5BdHRyaWJ1dGVWYWx1ZToCOAEiRQoPTGlzdE9mTW9kZW1JbmZvEjIKBWl0ZW1zGAEgAygLMiMuaW8uY2xicy5vcGVuaGVzLnBiZHJpdmVyLk1vZGVtSW5mbyJVChRMaXN0T2ZDb25uZWN0aW9uSW5mbxI9CgVpdGVtcxgBIAMoCzIuLmlvLmNsYnMub3Blbmhlcy5wYmRyaXZlci5EZXZpY2VDb25uZWN0aW9uSW5mbyppChJTZXJpYWxDb25maWdQYXJpdHkSDwoLUEFSSVRZX05PTkUQABIPCgtQQVJJVFlfRVZFThABEg4KClBBUklUWV9PREQQAhIPCgtQQVJJVFlfTUFSSxADEhAKDFBBUklUWV9TUEFDRRAEKssCChRTZXJpYWxDb25maWdCYXVkUmF0ZRIRCg1CQVVEX1JBVEVfMTEwEAASEQoNQkFVRF9SQVRFXzMwMBABEhEKDUJBVURfUkFURV82MDAQAhISCg5CQVVEX1JBVEVfMTIwMBADEhIKDkJBVURfUkFURV8yNDAwEAQSEgoOQkFVRF9SQVRFXzQ4MDAQBRISCg5CQVVEX1JBVEVfOTYwMBAGEhMKD0JBVURfUkFURV8xNDQwMBAHEhMKD0JBVURfUkFURV8xOTIwMBAIEhMKD0JBVURfUkFURV8zODQwMBAJEhMKD0JBVURfUkFURV81NzYwMBAKEhQKEEJBVURfUkFURV8xMTUyMDAQCxIUChBCQVVEX1JBVEVfMjMwNDAwEAwSFAoQQkFVRF9SQVRFXzQ2MDgwMBANEhQKEEJBVURfUkFURV85MjE2MDAQDipaChRTZXJpYWxDb25maWdEYXRhQml0cxIPCgtEQVRBX0JJVFNfNRAAEg8KC0RBVEFfQklUU182EAESDwoLREFUQV9CSVRTXzcQAhIPCgtEQVRBX0JJVFNfOBADKksKFFNlcmlhbENvbmZpZ1N0b3BCaXRzEg8KC1NUT1BfQklUU18xEAASEQoNU1RPUF9CSVRTXzFfNRABEg8KC1NUT1BfQklUU18yEAIqwQEKC0pvYlByaW9yaXR5EhIKDkpPQl9QUklPUklUWV8wEAASEgoOSk9CX1BSSU9SSVRZXzEQARISCg5KT0JfUFJJT1JJVFlfMhACEhIKDkpPQl9QUklPUklUWV8zEAMSEgoOSk9CX1BSSU9SSVRZXzQQBBISCg5KT0JfUFJJT1JJVFlfNRAFEhIKDkpPQl9QUklPUklUWV82EAYSEgoOSk9CX1BSSU9SSVRZXzcQBxISCg5KT0JfUFJJT1JJVFlfOBAIKtABCg1BdHRyaWJ1dGVUeXBlEhYKEkFUVFJJQlVURV9UWVBFX0lOVBAAEhkKFUFUVFJJQlVURV9UWVBFX1NUUklORxABEhkKFUFUVFJJQlVURV9UWVBFX0RPVUJMRRACEhkKFUFUVFJJQlVURV9UWVBFX0JJTkFSWRADEhwKGEFUVFJJQlVURV9UWVBFX1RJTUVTVEFNUBAEEh8KG0FUVFJJQlVURV9UWVBFX1RJTUVTVEFNUF9UWhAFEhcKE0FUVFJJQlVURV9UWVBFX0JPT0wQBiqLBAoKQWN0aW9uVHlwZRIcChhBQ1RJT05fVFlQRV9HRVRfUkVHSVNURVIQABImCiJBQ1RJT05fVFlQRV9HRVRfUEVSSU9ESUNBTF9QUk9GSUxFEAESJQohQUNUSU9OX1RZUEVfR0VUX0lSUkVHVUxBUl9QUk9GSUxFEAISGgoWQUNUSU9OX1RZUEVfR0VUX0VWRU5UUxADEhkKFUFDVElPTl9UWVBFX0dFVF9DTE9DSxAKEhoKFkFDVElPTl9UWVBFX1NZTkNfQ0xPQ0sQCxIfChtBQ1RJT05fVFlQRV9HRVRfUkVMQVlfU1RBVEUQFBIfChtBQ1RJT05fVFlQRV9TRVRfUkVMQVlfU1RBVEUQFRImCiJBQ1RJT05fVFlQRV9HRVRfRElTQ09OTkVDVE9SX1NUQVRFEBYSJgoiQUNUSU9OX1RZUEVfU0VUX0RJU0NPTk5FQ1RPUl9TVEFURRAXEhcKE0FDVElPTl9UWVBFX0dFVF9UT1UQGBIXChNBQ1RJT05fVFlQRV9TRVRfVE9VEBkSGwoXQUNUSU9OX1RZUEVfR0VUX0xJTUlURVIQGhIbChdBQ1RJT05fVFlQRV9TRVRfTElNSVRFUhAbEiQKIEFDVElPTl9UWVBFX1JFU0VUX0JJTExJTkdfUEVSSU9EECgSGQoVQUNUSU9OX1RZUEVfRldfVVBEQVRFEDIqiwEKEEFjdGlvblJlc3VsdENvZGUSGAoURVJST1JfQ09ERV9BQ1RJT05fT0sQABIhCh1FUlJPUl9DT0RFX0FDVElPTl9VTlNVUFBPUlRFRBABEh0KGUVSUk9SX0NPREVfQUNUSU9OX1BFTkRJTkcQAxIbChdFUlJPUl9DT0RFX0FDVElPTl9FUlJPUhAFKpcBCgxKb2JFcnJvckNvZGUSFwoTSk9CX0VSUk9SX0NPREVfTk9ORRAAEhcKE0pPQl9FUlJPUl9DT0RFX0JVU1kQARIYChRKT0JfRVJST1JfQ09ERV9FUlJPUhAFEiEKHUpPQl9FUlJPUl9DT0RFX0FMUkVBRFlfRVhJU1RTEAgSGAoUSk9CX0VSUk9SX0NPREVfRkFUQUwQCSo0CglFcnJvckNvZGUSEQoNRVJST1JfQ09ERV9PSxAAEhQKEEVSUk9SX0NPREVfRVJST1IQBCrKAQoRQ29tbXVuaWNhdGlvblR5cGUSHAoYQ09NTVVOSUNBVElPTl9UWVBFX1RDUElQEAASIQodQ09NTVVOSUNBVElPTl9UWVBFX01PREVNX1BPT0wQARIpCiVDT01NVU5JQ0FUSU9OX1RZUEVfU0VSSUFMX0xJTkVfRElSRUNUEAISJwojQ09NTVVOSUNBVElPTl9UWVBFX1NFUklBTF9MSU5FX01PWEEQAxIgChxDT01NVU5JQ0FUSU9OX1RZUEVfTElTVEVOSU5HEGMqpwEKEERhdGFMaW5rUHJvdG9jb2wSGgoWTElOS1BST1RPX0lFQ182MjA1Nl8yMRAAEhIKDkxJTktQUk9UT19IRExDEAESGwoXTElOS1BST1RPX0NPU0VNX1dSQVBQRVIQAhIUChBMSU5LUFJPVE9fTU9EQlVTEAMSEgoOTElOS1BST1RPX01CVVMQBBIcChhMSU5LUFJPVE9fTk9UX0FQUExJQ0FCTEUQYyquAQoTQXBwbGljYXRpb25Qcm90b2NvbBIZChVBUFBQUk9UT19JRUNfNjIwNTZfMjEQABIUChBBUFBQUk9UT19ETE1TX1NOEAESFAoQQVBQUFJPVE9fRExNU19MThACEhEKDUFQUFBST1RPX1NDVE0QAxITCg9BUFBQUk9UT19MSVMyMDAQBBIVChFBUFBQUk9UT19BTlNJX0MxMhAFEhEKDUFQUFBST1RPX01RVFQQBkI6WjhnaXRodWIuY29tL2N5YnJvc2xhYnMvaGVzLTItYXBpcy9wcm90b2J1Zi9wYmRyaXZlcm1vZGVsc2IIZWRpdGlvbnNw6Ac", [file_google_protobuf_empty, file_google_protobuf_timestamp]);

/**
 * Driver -> Taskmaster job/action progress update message
 *
 * @generated from message io.clbs.openhes.pbdriver.ProgressUpdate
 */
export type ProgressUpdate = Message<"io.clbs.openhes.pbdriver.ProgressUpdate"> & {
  /**
   * The oneof field containing the progress update data - either for job or for action.
   *
   * @generated from oneof io.clbs.openhes.pbdriver.ProgressUpdate.progress
   */
  progress: {
    /**
     * The job progress update data. It shall be called once and only once for each job. It shall be also called as the last message in the stream; other updates will be ignored after this.
     *
     * @generated from field: io.clbs.openhes.pbdriver.JobProgressUpdate job = 1;
     */
    value: JobProgressUpdate;
    case: "job";
  } | {
    /**
     * The action progress update data. It shall be called for each action in the job.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionProgressUpdate action = 2;
     */
    value: ActionProgressUpdate;
    case: "action";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ProgressUpdate.
 * Use `create(ProgressUpdateSchema)` to create a new message.
 */
export const ProgressUpdateSchema: GenMessage<ProgressUpdate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 0);

/**
 * Sub-message containing action progress update
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionProgressUpdate
 */
export type ActionProgressUpdate = Message<"io.clbs.openhes.pbdriver.ActionProgressUpdate"> & {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 2;
   */
  actionId: string;

  /**
   * The status related to the action.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ActionResultCode code = 3;
   */
  code: ActionResultCode;

  /**
   * The action result data. Shall be empty if the code is not OK.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ActionData data = 4;
   */
  data?: ActionData;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionProgressUpdate.
 * Use `create(ActionProgressUpdateSchema)` to create a new message.
 */
export const ActionProgressUpdateSchema: GenMessage<ActionProgressUpdate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 1);

/**
 * Sub-message containing job progress update
 *
 * @generated from message io.clbs.openhes.pbdriver.JobProgressUpdate
 */
export type JobProgressUpdate = Message<"io.clbs.openhes.pbdriver.JobProgressUpdate"> & {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The status related to the job and or action update message.
   *
   * @generated from field: io.clbs.openhes.pbdriver.JobErrorCode code = 2;
   */
  code: JobErrorCode;

  /**
   * The duration of the job in miliseconds.
   *
   * @generated from field: int64 duration = 3;
   */
  duration: bigint;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.JobProgressUpdate.
 * Use `create(JobProgressUpdateSchema)` to create a new message.
 */
export const JobProgressUpdateSchema: GenMessage<JobProgressUpdate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 2);

/**
 * Sub-message containing action-based variant of data values
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionData
 */
export type ActionData = Message<"io.clbs.openhes.pbdriver.ActionData"> & {
  /**
   * @generated from oneof io.clbs.openhes.pbdriver.ActionData.data
   */
  data: {
    /**
     * No data
     *
     * @generated from field: google.protobuf.Empty nodata = 1;
     */
    value: Empty;
    case: "nodata";
  } | {
    /**
     * Register values
     *
     * @generated from field: io.clbs.openhes.pbdriver.BillingValues billings = 2;
     */
    value: BillingValues;
    case: "billings";
  } | {
    /**
     * Profile values
     *
     * @generated from field: io.clbs.openhes.pbdriver.ProfileValues profile = 3;
     */
    value: ProfileValues;
    case: "profile";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionData.
 * Use `create(ActionDataSchema)` to create a new message.
 */
export const ActionDataSchema: GenMessage<ActionData> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 3);

/**
 * Sub-message containing profile-typed values
 *
 * @generated from message io.clbs.openhes.pbdriver.ProfileValues
 */
export type ProfileValues = Message<"io.clbs.openhes.pbdriver.ProfileValues"> & {
  /**
   * The period of the profile values.
   *
   * @generated from field: int32 period = 1;
   */
  period: number;

  /**
   * The unit of the profile values.
   *
   * @generated from field: string unit = 2;
   */
  unit: string;

  /**
   * The list of continuous profile blocks.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.ProfileBlok blocks = 3;
   */
  blocks: ProfileBlok[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ProfileValues.
 * Use `create(ProfileValuesSchema)` to create a new message.
 */
export const ProfileValuesSchema: GenMessage<ProfileValues> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 4);

/**
 * Sub-message containing a single profile block
 *
 * @generated from message io.clbs.openhes.pbdriver.ProfileBlok
 */
export type ProfileBlok = Message<"io.clbs.openhes.pbdriver.ProfileBlok"> & {
  /**
   * The start timestamp of the block.
   *
   * @generated from field: google.protobuf.Timestamp start_timestamp = 1;
   */
  startTimestamp?: Timestamp;

  /**
   * The list of profile values. Values are ordered by timestamp.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.MeasuredValue values = 2;
   */
  values: MeasuredValue[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ProfileBlok.
 * Use `create(ProfileBlokSchema)` to create a new message.
 */
export const ProfileBlokSchema: GenMessage<ProfileBlok> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 5);

/**
 * Sub-message containing billing-typed values
 *
 * @generated from message io.clbs.openhes.pbdriver.BillingValues
 */
export type BillingValues = Message<"io.clbs.openhes.pbdriver.BillingValues"> & {
  /**
   * The list of register values.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.BillingValue values = 1;
   */
  values: BillingValue[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.BillingValues.
 * Use `create(BillingValuesSchema)` to create a new message.
 */
export const BillingValuesSchema: GenMessage<BillingValues> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 6);

/**
 * Sub-message containing billing-typed value
 *
 * @generated from message io.clbs.openhes.pbdriver.BillingValue
 */
export type BillingValue = Message<"io.clbs.openhes.pbdriver.BillingValue"> & {
  /**
   * The timestamp of the value.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The unit of the value.
   *
   * @generated from field: string unit = 2;
   */
  unit: string;

  /**
   * The value.
   *
   * @generated from field: io.clbs.openhes.pbdriver.MeasuredValue value = 3;
   */
  value?: MeasuredValue;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.BillingValue.
 * Use `create(BillingValueSchema)` to create a new message.
 */
export const BillingValueSchema: GenMessage<BillingValue> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 7);

/**
 * Sub-message containing measured value
 *
 * @generated from message io.clbs.openhes.pbdriver.MeasuredValue
 */
export type MeasuredValue = Message<"io.clbs.openhes.pbdriver.MeasuredValue"> & {
  /**
   * The status of the value.
   *
   * @generated from field: int64 status = 1;
   */
  status: bigint;

  /**
   * The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
   *
   * @generated from field: int32 exponent = 2;
   */
  exponent: number;

  /**
   * @generated from oneof io.clbs.openhes.pbdriver.MeasuredValue.value
   */
  value: {
    /**
     * The double-typed value.
     *
     * @generated from field: double double_value = 3;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * The integer-typed value.
     *
     * @generated from field: int64 int_value = 4;
     */
    value: bigint;
    case: "intValue";
  } | {
    /**
     * The string-typed value.
     *
     * @generated from field: string str_value = 5;
     */
    value: string;
    case: "strValue";
  } | {
    /**
     * The timestamp-typed value.
     *
     * @generated from field: google.protobuf.Timestamp timestamp_value = 6;
     */
    value: Timestamp;
    case: "timestampValue";
  } | {
    /**
     * The timestamp with timezone-typed value, stored as string in ISO-8601.
     *
     * @generated from field: string timestamp_tz_value = 7;
     */
    value: string;
    case: "timestampTzValue";
  } | {
    /**
     * The boolean-typed value.
     *
     * @generated from field: bool bool_value = 8;
     */
    value: boolean;
    case: "boolValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.MeasuredValue.
 * Use `create(MeasuredValueSchema)` to create a new message.
 */
export const MeasuredValueSchema: GenMessage<MeasuredValue> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 8);

/**
 * Sub-message containing attribute definition
 *
 * @generated from message io.clbs.openhes.pbdriver.AttributeDefinition
 */
export type AttributeDefinition = Message<"io.clbs.openhes.pbdriver.AttributeDefinition"> & {
  /**
   * The name of the attribute.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The description of the attribute.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * The type of the attribute.
   *
   * @generated from field: io.clbs.openhes.pbdriver.AttributeType type = 3;
   */
  type: AttributeType;

  /**
   * The attribute is mandatory or not.
   *
   * @generated from field: bool mandatory = 4;
   */
  mandatory: boolean;

  /**
   * The default value of the attribute.
   *
   * @generated from field: io.clbs.openhes.pbdriver.AttributeValue default_value = 5;
   */
  defaultValue?: AttributeValue;

  /**
   * Optional. The list of values (represented by keys) that can be set. The value is the human-readable description in English (translations are applies using i18 or similar framework outside of the templates). If no values is defined then any value is allowed.
   *
   * @generated from field: map<string, string> options = 6;
   */
  options: { [key: string]: string };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.AttributeDefinition.
 * Use `create(AttributeDefinitionSchema)` to create a new message.
 */
export const AttributeDefinitionSchema: GenMessage<AttributeDefinition> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 9);

/**
 * Sub-message containing job action attributes
 *
 * @generated from message io.clbs.openhes.pbdriver.JobActionAttributes
 */
export type JobActionAttributes = Message<"io.clbs.openhes.pbdriver.JobActionAttributes"> & {
  /**
   * The type of action for which this instance of the template is defined.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ActionType type = 1;
   */
  type: ActionType;

  /**
   * The template of the action attributes. It is represented as a list of attribute definitions.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.AttributeDefinition attributes = 2;
   */
  attributes: AttributeDefinition[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.JobActionAttributes.
 * Use `create(JobActionAttributesSchema)` to create a new message.
 */
export const JobActionAttributesSchema: GenMessage<JobActionAttributes> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 10);

/**
 * Taskmaster -> Driver start job request message
 *
 * @generated from message io.clbs.openhes.pbdriver.StartJobsRequest
 */
export type StartJobsRequest = Message<"io.clbs.openhes.pbdriver.StartJobsRequest"> & {
  /**
   * The connection info for the job.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ConnectionInfo connection_info = 2;
   */
  connectionInfo?: ConnectionInfo;

  /**
   * The list of jobs to be started with the same connection info.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.StartJobData jobs = 1;
   */
  jobs: StartJobData[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.StartJobsRequest.
 * Use `create(StartJobsRequestSchema)` to create a new message.
 */
export const StartJobsRequestSchema: GenMessage<StartJobsRequest> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 11);

/**
 * Sub-message containing job start request for single device
 *
 * @generated from message io.clbs.openhes.pbdriver.StartJobData
 */
export type StartJobData = Message<"io.clbs.openhes.pbdriver.StartJobData"> & {
  /**
   * The device attributes. For example HDLC address, password and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.pbdriver.AttributeValue> device_attributes = 1;
   */
  deviceAttributes: { [key: string]: AttributeValue };

  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 2;
   */
  jobId: string;

  /**
   * The job parameters.
   *
   * @generated from field: io.clbs.openhes.pbdriver.JobSettings job_settings = 3;
   */
  jobSettings?: JobSettings;

  /**
   * The list actions to be executed.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.JobAction job_actions = 4;
   */
  jobActions: JobAction[];

  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ApplicationProtocol app_protocol = 5;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
   *
   * @generated from field: string timezone = 6;
   */
  timezone: string;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.StartJobData.
 * Use `create(StartJobDataSchema)` to create a new message.
 */
export const StartJobDataSchema: GenMessage<StartJobData> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 12);

/**
 * Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
 *
 * @generated from message io.clbs.openhes.pbdriver.ConnectionTypeControlledSerial
 */
export type ConnectionTypeControlledSerial = Message<"io.clbs.openhes.pbdriver.ConnectionTypeControlledSerial"> & {
  /**
   * IP-to-serial converter description.
   *
   * @generated from oneof io.clbs.openhes.pbdriver.ConnectionTypeControlledSerial.converter
   */
  converter: {
    /**
     * The simple direct serial connection type.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ConnectionTypeSerialDirect direct = 1;
     */
    value: ConnectionTypeSerialDirect;
    case: "direct";
  } | {
    /**
     * The Moxa connection type.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ConnectionTypeSerialMoxa moxa = 2;
     */
    value: ConnectionTypeSerialMoxa;
    case: "moxa";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ConnectionTypeControlledSerial.
 * Use `create(ConnectionTypeControlledSerialSchema)` to create a new message.
 */
export const ConnectionTypeControlledSerialSchema: GenMessage<ConnectionTypeControlledSerial> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 13);

/**
 * Sub-message containing modem connection info
 *
 * @generated from message io.clbs.openhes.pbdriver.ModemInfo
 */
export type ModemInfo = Message<"io.clbs.openhes.pbdriver.ModemInfo"> & {
  /**
   * The modem identifier. It is automatically generated during creation.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The name of the modem.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The modem initialization command.
   *
   * @generated from field: string at_init = 3;
   */
  atInit: string;

  /**
   * The modem test command.
   *
   * @generated from field: string at_test = 4;
   */
  atTest: string;

  /**
   * The modem configuration command.
   *
   * @generated from field: string at_config = 5;
   */
  atConfig: string;

  /**
   * The modem dial command.
   *
   * @generated from field: string at_dial = 6;
   */
  atDial: string;

  /**
   * The modem hangup command.
   *
   * @generated from field: string at_hangup = 7;
   */
  atHangup: string;

  /**
   * The modem escape command.
   *
   * @generated from field: string at_escape = 8;
   */
  atEscape: string;

  /**
   * The modem DSR command.
   *
   * @generated from field: bool at_dsr = 9;
   */
  atDsr: boolean;

  /**
   * The modem connection timeout.
   *
   * @generated from field: uint32 connect_timeout = 10;
   */
  connectTimeout: number;

  /**
   * The modem connection description.
   *
   * @generated from oneof io.clbs.openhes.pbdriver.ModemInfo.modem_connection
   */
  modemConnection: {
    /**
     * The TCP connection type. The modem has either TCP or there is a IP-to-serial converter which handles the serial configuration so no additional serial configuration is needed.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ConnectionTypeDirectTcpIp tcpip = 11;
     */
    value: ConnectionTypeDirectTcpIp;
    case: "tcpip";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ModemInfo.
 * Use `create(ModemInfoSchema)` to create a new message.
 */
export const ModemInfoSchema: GenMessage<ModemInfo> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 14);

/**
 * Sub-message containing serial port configuration
 *
 * @generated from message io.clbs.openhes.pbdriver.SerialConfig
 */
export type SerialConfig = Message<"io.clbs.openhes.pbdriver.SerialConfig"> & {
  /**
   * The baud rate.
   *
   * @generated from field: io.clbs.openhes.pbdriver.SerialConfigBaudRate baud_rate = 1;
   */
  baudRate: SerialConfigBaudRate;

  /**
   * The parity.
   *
   * @generated from field: io.clbs.openhes.pbdriver.SerialConfigParity parity = 2;
   */
  parity: SerialConfigParity;

  /**
   * The data bits.
   *
   * @generated from field: io.clbs.openhes.pbdriver.SerialConfigDataBits data_bits = 3;
   */
  dataBits: SerialConfigDataBits;

  /**
   * The stop bits.
   *
   * @generated from field: io.clbs.openhes.pbdriver.SerialConfigStopBits stop_bits = 4;
   */
  stopBits: SerialConfigStopBits;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.SerialConfig.
 * Use `create(SerialConfigSchema)` to create a new message.
 */
export const SerialConfigSchema: GenMessage<SerialConfig> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 15);

/**
 * Sub-message containing connection info
 *
 * @generated from message io.clbs.openhes.pbdriver.ConnectionInfo
 */
export type ConnectionInfo = Message<"io.clbs.openhes.pbdriver.ConnectionInfo"> & {
  /**
   * The entrypoint connection description. It can be either direct TCP, a modem from a pool or a direct serial line over IP (using IP-to-serial converter).
   *
   * @generated from oneof io.clbs.openhes.pbdriver.ConnectionInfo.connection
   */
  connection: {
    /**
     * The TCP connection type.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ConnectionTypeDirectTcpIp tcpip = 1;
     */
    value: ConnectionTypeDirectTcpIp;
    case: "tcpip";
  } | {
    /**
     * The phone connection type.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ConnectionTypeModemPool modem_pool = 2;
     */
    value: ConnectionTypeModemPool;
    case: "modemPool";
  } | {
    /**
     * The serial over IP connection type.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ConnectionTypeControlledSerial serial_over_ip = 3;
     */
    value: ConnectionTypeControlledSerial;
    case: "serialOverIp";
  } | { case: undefined; value?: undefined };

  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.pbdriver.DataLinkProtocol link_protocol = 4;
   */
  linkProtocol: DataLinkProtocol;

  /**
   * The custom group ID to link jobs together. If not set then jobs are grouped by group-key defined based on the connection type.
   *
   * @generated from field: string custom_grouping_id = 5;
   */
  customGroupingId: string;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ConnectionInfo.
 * Use `create(ConnectionInfoSchema)` to create a new message.
 */
export const ConnectionInfoSchema: GenMessage<ConnectionInfo> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 16);

/**
 * Sub-message containing connection info for TCP connection type
 *
 * @generated from message io.clbs.openhes.pbdriver.ConnectionTypeDirectTcpIp
 */
export type ConnectionTypeDirectTcpIp = Message<"io.clbs.openhes.pbdriver.ConnectionTypeDirectTcpIp"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;

  /**
   * The timeout in miliseconds for the connection.
   *
   * @generated from field: int32 timeout = 3;
   */
  timeout: number;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ConnectionTypeDirectTcpIp.
 * Use `create(ConnectionTypeDirectTcpIpSchema)` to create a new message.
 */
export const ConnectionTypeDirectTcpIpSchema: GenMessage<ConnectionTypeDirectTcpIp> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 17);

/**
 * Sub-message containing connection info for phone line (modem) connection type
 *
 * @generated from message io.clbs.openhes.pbdriver.ConnectionTypeModemPool
 */
export type ConnectionTypeModemPool = Message<"io.clbs.openhes.pbdriver.ConnectionTypeModemPool"> & {
  /**
   * The phone number of the device to connect to.
   *
   * @generated from field: string number = 1;
   */
  number: string;

  /**
   * The modem pool identifier. The pool is a group of modems that can be used to connect to the device. Final modem is selected by the Taskmaster at the time of the job start.
   *
   * @generated from field: string pool_id = 2;
   */
  poolId: string;

  /**
   * The modem device assigned to the job. This is filled only and only when the connection type is modem. The value is assigned by the Taskmaster when to job is being started. Driver is required to use this modem device to connect to the meter only and only for the time of this job!
   *
   * @generated from field: io.clbs.openhes.pbdriver.ModemInfo modem = 4;
   */
  modem?: ModemInfo;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ConnectionTypeModemPool.
 * Use `create(ConnectionTypeModemPoolSchema)` to create a new message.
 */
export const ConnectionTypeModemPoolSchema: GenMessage<ConnectionTypeModemPool> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 18);

/**
 * @generated from message io.clbs.openhes.pbdriver.ConnectionTypeSerialDirect
 */
export type ConnectionTypeSerialDirect = Message<"io.clbs.openhes.pbdriver.ConnectionTypeSerialDirect"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to.
   *
   * @generated from field: uint32 port = 2;
   */
  port: number;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ConnectionTypeSerialDirect.
 * Use `create(ConnectionTypeSerialDirectSchema)` to create a new message.
 */
export const ConnectionTypeSerialDirectSchema: GenMessage<ConnectionTypeSerialDirect> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 19);

/**
 * Sub-message containing connection info for controlled-serial line (Moxa) connection type
 *
 * @generated from message io.clbs.openhes.pbdriver.ConnectionTypeSerialMoxa
 */
export type ConnectionTypeSerialMoxa = Message<"io.clbs.openhes.pbdriver.ConnectionTypeSerialMoxa"> & {
  /**
   * The host name or IP address of the device to connect to.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The TCP port number of the device to connect to - data port.
   *
   * @generated from field: uint32 dataPort = 2;
   */
  dataPort: number;

  /**
   * The TCP port number of the device to connect to - command port.
   *
   * @generated from field: uint32 commandPort = 3;
   */
  commandPort: number;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ConnectionTypeSerialMoxa.
 * Use `create(ConnectionTypeSerialMoxaSchema)` to create a new message.
 */
export const ConnectionTypeSerialMoxaSchema: GenMessage<ConnectionTypeSerialMoxa> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 20);

/**
 * Sub-message containing job parameters
 *
 * @generated from message io.clbs.openhes.pbdriver.JobSettings
 */
export type JobSettings = Message<"io.clbs.openhes.pbdriver.JobSettings"> & {
  /**
   * Maximum duration of the job attempt in miliseconds. This is related to the real time for the driver.
   *
   * @generated from field: int64 max_duration = 1;
   */
  maxDuration: bigint;

  /**
   * Priority of the job.
   *
   * @generated from field: io.clbs.openhes.pbdriver.JobPriority priority = 2;
   */
  priority: JobPriority;

  /**
   * Maximum number of attempts, 1 is the minimum.
   *
   * @generated from field: repeated int32 attempts = 3;
   */
  attempts: number[];

  /**
   * Delay in miliseconds between two attempts.
   *
   * @generated from field: int64 retry_delay = 4;
   */
  retryDelay: bigint;

  /**
   * Number of miliseconds to wait before starting the job.
   *
   * @generated from field: uint64 defer_start = 5;
   */
  deferStart: bigint;

  /**
   * The timestamp when the job expires.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 6;
   */
  expiresAt?: Timestamp;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.JobSettings.
 * Use `create(JobSettingsSchema)` to create a new message.
 */
export const JobSettingsSchema: GenMessage<JobSettings> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 21);

/**
 * Sub-message containing job action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.JobAction
 */
export type JobAction = Message<"io.clbs.openhes.pbdriver.JobAction"> & {
  /**
   * The action identifier.
   *
   * @generated from field: string action_id = 1;
   */
  actionId: string;

  /**
   * The action attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.pbdriver.AttributeValue> attributes = 2;
   */
  attributes: { [key: string]: AttributeValue };

  /**
   * @generated from oneof io.clbs.openhes.pbdriver.JobAction.action
   */
  action: {
    /**
     * The get register action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetRegister get_register = 3;
     */
    value: ActionGetRegister;
    case: "getRegister";
  } | {
    /**
     * The get periodical profile action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetPeriodicalProfile get_periodical_profile = 4;
     */
    value: ActionGetPeriodicalProfile;
    case: "getPeriodicalProfile";
  } | {
    /**
     * The get irregular profile action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetIrregularProfile get_irregular_profile = 5;
     */
    value: ActionGetIrregularProfile;
    case: "getIrregularProfile";
  } | {
    /**
     * The get events action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetEvents get_events = 6;
     */
    value: ActionGetEvents;
    case: "getEvents";
  } | {
    /**
     * The get clock action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetClock get_clock = 7;
     */
    value: ActionGetClock;
    case: "getClock";
  } | {
    /**
     * The sync clock action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionSyncClock sync_clock = 8;
     */
    value: ActionSyncClock;
    case: "syncClock";
  } | {
    /**
     * The get relay state action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetRelayState get_relay_state = 9;
     */
    value: ActionGetRelayState;
    case: "getRelayState";
  } | {
    /**
     * The set relay state action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionSetRelayState set_relay_state = 10;
     */
    value: ActionSetRelayState;
    case: "setRelayState";
  } | {
    /**
     * The get disconnector state action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetDisconnectorState get_disconnector_state = 11;
     */
    value: ActionGetDisconnectorState;
    case: "getDisconnectorState";
  } | {
    /**
     * The set disconnector state action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionSetDisconnectorState set_disconnector_state = 12;
     */
    value: ActionSetDisconnectorState;
    case: "setDisconnectorState";
  } | {
    /**
     * The get tou action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetTou get_tou = 13;
     */
    value: ActionGetTou;
    case: "getTou";
  } | {
    /**
     * The set tou action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionSetTou set_tou = 14;
     */
    value: ActionSetTou;
    case: "setTou";
  } | {
    /**
     * The get limiter action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionGetLimiter get_limiter = 15;
     */
    value: ActionGetLimiter;
    case: "getLimiter";
  } | {
    /**
     * The set limiter action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionSetLimiter set_limiter = 16;
     */
    value: ActionSetLimiter;
    case: "setLimiter";
  } | {
    /**
     * The reset billing period action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionResetBillingPeriod reset_billing_period = 17;
     */
    value: ActionResetBillingPeriod;
    case: "resetBillingPeriod";
  } | {
    /**
     * The firmware update action specification.
     *
     * @generated from field: io.clbs.openhes.pbdriver.ActionFwUpdate fw_update = 18;
     */
    value: ActionFwUpdate;
    case: "fwUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.JobAction.
 * Use `create(JobActionSchema)` to create a new message.
 */
export const JobActionSchema: GenMessage<JobAction> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 22);

/**
 * Sub-message containing get register action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetRegister
 */
export type ActionGetRegister = Message<"io.clbs.openhes.pbdriver.ActionGetRegister"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetRegister.
 * Use `create(ActionGetRegisterSchema)` to create a new message.
 */
export const ActionGetRegisterSchema: GenMessage<ActionGetRegister> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 23);

/**
 * Sub-message containing get periodical profile action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetPeriodicalProfile
 */
export type ActionGetPeriodicalProfile = Message<"io.clbs.openhes.pbdriver.ActionGetPeriodicalProfile"> & {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetPeriodicalProfile.
 * Use `create(ActionGetPeriodicalProfileSchema)` to create a new message.
 */
export const ActionGetPeriodicalProfileSchema: GenMessage<ActionGetPeriodicalProfile> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 24);

/**
 * Sub-message containing get irregular profile action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetIrregularProfile
 */
export type ActionGetIrregularProfile = Message<"io.clbs.openhes.pbdriver.ActionGetIrregularProfile"> & {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetIrregularProfile.
 * Use `create(ActionGetIrregularProfileSchema)` to create a new message.
 */
export const ActionGetIrregularProfileSchema: GenMessage<ActionGetIrregularProfile> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 25);

/**
 * Sub-message containing get events action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetEvents
 */
export type ActionGetEvents = Message<"io.clbs.openhes.pbdriver.ActionGetEvents"> & {
  /**
   * The start timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * The end timestamp of the profile.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetEvents.
 * Use `create(ActionGetEventsSchema)` to create a new message.
 */
export const ActionGetEventsSchema: GenMessage<ActionGetEvents> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 26);

/**
 * Sub-message containing get clock action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetClock
 */
export type ActionGetClock = Message<"io.clbs.openhes.pbdriver.ActionGetClock"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetClock.
 * Use `create(ActionGetClockSchema)` to create a new message.
 */
export const ActionGetClockSchema: GenMessage<ActionGetClock> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 27);

/**
 * Sub-message containing sync clock action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionSyncClock
 */
export type ActionSyncClock = Message<"io.clbs.openhes.pbdriver.ActionSyncClock"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionSyncClock.
 * Use `create(ActionSyncClockSchema)` to create a new message.
 */
export const ActionSyncClockSchema: GenMessage<ActionSyncClock> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 28);

/**
 * Sub-message containing get relay state action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetRelayState
 */
export type ActionGetRelayState = Message<"io.clbs.openhes.pbdriver.ActionGetRelayState"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetRelayState.
 * Use `create(ActionGetRelayStateSchema)` to create a new message.
 */
export const ActionGetRelayStateSchema: GenMessage<ActionGetRelayState> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 29);

/**
 * Sub-message containing set relay state action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionSetRelayState
 */
export type ActionSetRelayState = Message<"io.clbs.openhes.pbdriver.ActionSetRelayState"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionSetRelayState.
 * Use `create(ActionSetRelayStateSchema)` to create a new message.
 */
export const ActionSetRelayStateSchema: GenMessage<ActionSetRelayState> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 30);

/**
 * Sub-message containing get disconnector state action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetDisconnectorState
 */
export type ActionGetDisconnectorState = Message<"io.clbs.openhes.pbdriver.ActionGetDisconnectorState"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetDisconnectorState.
 * Use `create(ActionGetDisconnectorStateSchema)` to create a new message.
 */
export const ActionGetDisconnectorStateSchema: GenMessage<ActionGetDisconnectorState> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 31);

/**
 * Sub-message containing set disconnector state action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionSetDisconnectorState
 */
export type ActionSetDisconnectorState = Message<"io.clbs.openhes.pbdriver.ActionSetDisconnectorState"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionSetDisconnectorState.
 * Use `create(ActionSetDisconnectorStateSchema)` to create a new message.
 */
export const ActionSetDisconnectorStateSchema: GenMessage<ActionSetDisconnectorState> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 32);

/**
 * Sub-message containing get tou action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetTou
 */
export type ActionGetTou = Message<"io.clbs.openhes.pbdriver.ActionGetTou"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetTou.
 * Use `create(ActionGetTouSchema)` to create a new message.
 */
export const ActionGetTouSchema: GenMessage<ActionGetTou> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 33);

/**
 * Sub-message containing set tou action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionSetTou
 */
export type ActionSetTou = Message<"io.clbs.openhes.pbdriver.ActionSetTou"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionSetTou.
 * Use `create(ActionSetTouSchema)` to create a new message.
 */
export const ActionSetTouSchema: GenMessage<ActionSetTou> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 34);

/**
 * Sub-message containing get limiter action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionGetLimiter
 */
export type ActionGetLimiter = Message<"io.clbs.openhes.pbdriver.ActionGetLimiter"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionGetLimiter.
 * Use `create(ActionGetLimiterSchema)` to create a new message.
 */
export const ActionGetLimiterSchema: GenMessage<ActionGetLimiter> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 35);

/**
 * Sub-message containing set limiter action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionSetLimiter
 */
export type ActionSetLimiter = Message<"io.clbs.openhes.pbdriver.ActionSetLimiter"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionSetLimiter.
 * Use `create(ActionSetLimiterSchema)` to create a new message.
 */
export const ActionSetLimiterSchema: GenMessage<ActionSetLimiter> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 36);

/**
 * Sub-message containing reset billing period action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionResetBillingPeriod
 */
export type ActionResetBillingPeriod = Message<"io.clbs.openhes.pbdriver.ActionResetBillingPeriod"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionResetBillingPeriod.
 * Use `create(ActionResetBillingPeriodSchema)` to create a new message.
 */
export const ActionResetBillingPeriodSchema: GenMessage<ActionResetBillingPeriod> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 37);

/**
 * Sub-message containing firmware update action specification
 *
 * @generated from message io.clbs.openhes.pbdriver.ActionFwUpdate
 */
export type ActionFwUpdate = Message<"io.clbs.openhes.pbdriver.ActionFwUpdate"> & {
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ActionFwUpdate.
 * Use `create(ActionFwUpdateSchema)` to create a new message.
 */
export const ActionFwUpdateSchema: GenMessage<ActionFwUpdate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 38);

/**
 * Sub-message containing single attribute value specification
 *
 * @generated from message io.clbs.openhes.pbdriver.AttributeValue
 */
export type AttributeValue = Message<"io.clbs.openhes.pbdriver.AttributeValue"> & {
  /**
   * @generated from oneof io.clbs.openhes.pbdriver.AttributeValue.value
   */
  value: {
    /**
     * The string-typed value.
     *
     * @generated from field: string str_value = 1;
     */
    value: string;
    case: "strValue";
  } | {
    /**
     * The integer-typed value.
     *
     * @generated from field: int64 int_value = 2;
     */
    value: bigint;
    case: "intValue";
  } | {
    /**
     * The double-typed value.
     *
     * @generated from field: double double_value = 3;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * The binary-typed value.
     *
     * @generated from field: bytes binary_value = 4;
     */
    value: Uint8Array;
    case: "binaryValue";
  } | {
    /**
     * The boolean-typed value.
     *
     * @generated from field: bool bool_value = 5;
     */
    value: boolean;
    case: "boolValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.AttributeValue.
 * Use `create(AttributeValueSchema)` to create a new message.
 */
export const AttributeValueSchema: GenMessage<AttributeValue> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 39);

/**
 * Common gRPC response message
 *
 * @generated from message io.clbs.openhes.pbdriver.CommonResponse
 */
export type CommonResponse = Message<"io.clbs.openhes.pbdriver.CommonResponse"> & {
  /**
   * The result of the operation.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ErrorCode result = 1;
   */
  result: ErrorCode;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.CommonResponse.
 * Use `create(CommonResponseSchema)` to create a new message.
 */
export const CommonResponseSchema: GenMessage<CommonResponse> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 40);

/**
 * Sub-message containing destription for one application protocol, e.g. DLMS_SN.
 *
 * @generated from message io.clbs.openhes.pbdriver.ApplicationProtocolTemplate
 */
export type ApplicationProtocolTemplate = Message<"io.clbs.openhes.pbdriver.ApplicationProtocolTemplate"> & {
  /**
   * Unique identifier of the application protocol.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The application protocol.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ApplicationProtocol protocol = 2;
   */
  protocol: ApplicationProtocol;

  /**
   * The list of attribute definitions for the protocol.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.AttributeDefinition attributes = 3;
   */
  attributes: AttributeDefinition[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ApplicationProtocolTemplate.
 * Use `create(ApplicationProtocolTemplateSchema)` to create a new message.
 */
export const ApplicationProtocolTemplateSchema: GenMessage<ApplicationProtocolTemplate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 41);

/**
 * Sub-message containing destription for one data link protocol, e.g. HDLC.
 *
 * @generated from message io.clbs.openhes.pbdriver.DataLinkTemplate
 */
export type DataLinkTemplate = Message<"io.clbs.openhes.pbdriver.DataLinkTemplate"> & {
  /**
   * The data link protocol.
   *
   * @generated from field: io.clbs.openhes.pbdriver.DataLinkProtocol link_protocol = 1;
   */
  linkProtocol: DataLinkProtocol;

  /**
   * The list of application protocol identifiers supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.ApplicationProtocol app_protocol_refs = 2;
   */
  appProtocolRefs: ApplicationProtocol[];

  /**
   * The list of attribute definitions related to given data link type (see link_protocol property) and all those will be instantiated for each device.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.AttributeDefinition attributes = 3;
   */
  attributes: AttributeDefinition[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.DataLinkTemplate.
 * Use `create(DataLinkTemplateSchema)` to create a new message.
 */
export const DataLinkTemplateSchema: GenMessage<DataLinkTemplate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 42);

/**
 * Sub-message containing destription for one communication type, e.g. TCP/IP.
 *
 * @generated from message io.clbs.openhes.pbdriver.CommunicationTemplate
 */
export type CommunicationTemplate = Message<"io.clbs.openhes.pbdriver.CommunicationTemplate"> & {
  /**
   * The type of the communication.
   *
   * @generated from field: io.clbs.openhes.pbdriver.CommunicationType type = 1;
   */
  type: CommunicationType;

  /**
   * The list of data link protocols and their app protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.DataLinkTemplate datalinks = 2;
   */
  datalinks: DataLinkTemplate[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.CommunicationTemplate.
 * Use `create(CommunicationTemplateSchema)` to create a new message.
 */
export const CommunicationTemplateSchema: GenMessage<CommunicationTemplate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 43);

/**
 * Sub-message containing access level definition
 *
 * @generated from message io.clbs.openhes.pbdriver.AccessLevelTemplate
 */
export type AccessLevelTemplate = Message<"io.clbs.openhes.pbdriver.AccessLevelTemplate"> & {
  /**
   * The access level identifier, such as "1", "G", "16" or similar.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The access level name. Should be in English and unique for given driver, e.g. "Management", "Public".
   *
   * @generated from field: string name = 2;
   */
  name: string;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.AccessLevelTemplate.
 * Use `create(AccessLevelTemplateSchema)` to create a new message.
 */
export const AccessLevelTemplateSchema: GenMessage<AccessLevelTemplate> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 44);

/**
 * Sub-message in driver negotiation request
 *
 * @generated from message io.clbs.openhes.pbdriver.DriverTemplates
 */
export type DriverTemplates = Message<"io.clbs.openhes.pbdriver.DriverTemplates"> & {
  /**
   * The templates of the communication options. Every template represents an option how the drivers allows to communicate. The driver can support multiple communication templates.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.CommunicationTemplate communication_templates = 1;
   */
  communicationTemplates: CommunicationTemplate[];

  /**
   * The templates of the application protocols supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.ApplicationProtocolTemplate app_protocols = 2;
   */
  appProtocols: ApplicationProtocolTemplate[];

  /**
   * The templates of the job actions for all supported action types. It must contain every action type supported by the driver once and only once.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.JobActionAttributes action_attributes = 3;
   */
  actionAttributes: JobActionAttributes[];

  /**
   * The templates of the access levels supported by the driver.
   *
   * @generated from field: repeated io.clbs.openhes.pbdriver.AccessLevelTemplate access_templates = 4;
   */
  accessTemplates: AccessLevelTemplate[];

  /**
   * The templates of the job actions constraints.
   *
   * @generated from field: io.clbs.openhes.pbdriver.JobActionContraints action_constraints = 5;
   */
  actionConstraints?: JobActionContraints;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.DriverTemplates.
 * Use `create(DriverTemplatesSchema)` to create a new message.
 */
export const DriverTemplatesSchema: GenMessage<DriverTemplates> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 45);

/**
 * Defines a mesasge as a list of strings.
 *
 * @generated from message io.clbs.openhes.pbdriver.StringList
 */
export type StringList = Message<"io.clbs.openhes.pbdriver.StringList"> & {
  /**
   * The list of strings.
   *
   * @generated from field: repeated string items = 1;
   */
  items: string[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.StringList.
 * Use `create(StringListSchema)` to create a new message.
 */
export const StringListSchema: GenMessage<StringList> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 46);

/**
 * Sub-message containing constraints for job actions.
 *
 * @generated from message io.clbs.openhes.pbdriver.JobActionContraints
 */
export type JobActionContraints = Message<"io.clbs.openhes.pbdriver.JobActionContraints"> & {
  /**
   * Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, string> get_register_type_name = 1;
   */
  getRegisterTypeName: { [key: string]: string };

  /**
   * Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
   * See JobActionAttributes for the attribute definitions.
   * Action: ACTION_TYPE_GET_REGISTER
   *
   * @generated from field: map<string, io.clbs.openhes.pbdriver.StringList> get_register_type_attributes = 2;
   */
  getRegisterTypeAttributes: { [key: string]: StringList };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.JobActionContraints.
 * Use `create(JobActionContraintsSchema)` to create a new message.
 */
export const JobActionContraintsSchema: GenMessage<JobActionContraints> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 47);

/**
 * Taskmaster -> Driver cancel job request message
 *
 * @generated from message io.clbs.openhes.pbdriver.CancelJobRequest
 */
export type CancelJobRequest = Message<"io.clbs.openhes.pbdriver.CancelJobRequest"> & {
  /**
   * The job identifier.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.CancelJobRequest.
 * Use `create(CancelJobRequestSchema)` to create a new message.
 */
export const CancelJobRequestSchema: GenMessage<CancelJobRequest> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 48);

/**
 * Driver -> Taskmaster negotiate/health-check request message
 *
 * @generated from message io.clbs.openhes.pbdriver.NegotiateRequest
 */
export type NegotiateRequest = Message<"io.clbs.openhes.pbdriver.NegotiateRequest"> & {
  /**
   * The driver version. The format is not defined. The driver itself is versioned by the docker image tags so this value shall be either the same (set during the image build) or any useful user-readable version string.
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * The port the driver's gRPC will listen on.
   *
   * @generated from field: uint32 listening_port = 2;
   */
  listeningPort: number;

  /**
   * The technical/internal ID of the driver.
   *
   * @generated from field: string driver_type = 3;
   */
  driverType: string;

  /**
   * The maximum number of concurrent jobs the driver can handle. The value 0 is not allowed, the maximum number respect typical_mem_usage not to overgrow the memory resources!
   *
   * @generated from field: int32 max_concurrent_jobs = 4;
   */
  maxConcurrentJobs: number;

  /**
   * The maximum cascade depth the driver can handle. Number 1 means that the driver cannot handle cascading jobs, 2 means that the driver can handle cascading jobs with one level of depth, etc.
   * The value 0 means that the driver can handle any number of cascading jobs.
   *
   * @generated from field: uint32 max_cascade_depth = 5;
   */
  maxCascadeDepth: number;

  /**
   * The typical memory usage of the driver in MB.
   *
   * @generated from field: int32 typical_mem_usage = 6;
   */
  typicalMemUsage: number;

  /**
   * The connection and action templates.
   *
   * @generated from field: io.clbs.openhes.pbdriver.DriverTemplates templates = 7;
   */
  templates?: DriverTemplates;

  /**
   * The display name of the driver. Must be in format '<manufacturer> <device_type> [<device_type_version>]'.
   * It must respect upper/lower characters.
   * The generic drivers, such as 'cybros labs generic', must be named as '<driver_company_name> generic'.
   *
   * Examples: 'Addax NP73E', 'cybros labs generic', 'Landis+Gyr S650 v2'
   *
   * @generated from field: string display_name = 8;
   */
  displayName: string;
};

/**
 * Describes the message io.clbs.openhes.pbdriver.NegotiateRequest.
 * Use `create(NegotiateRequestSchema)` to create a new message.
 */
export const NegotiateRequestSchema: GenMessage<NegotiateRequest> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 49);

/**
 * Addon
 *
 * @generated from message io.clbs.openhes.pbdriver.DeviceConnectionInfo
 */
export type DeviceConnectionInfo = Message<"io.clbs.openhes.pbdriver.DeviceConnectionInfo"> & {
  /**
   * The unique identifier of the communication unit.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ConnectionInfo communication_unit = 1;
   */
  communicationUnit?: ConnectionInfo;

  /**
   * The application protocol to be used for the communication over the communication unit.
   *
   * @generated from field: io.clbs.openhes.pbdriver.ApplicationProtocol app_protocol = 2;
   */
  appProtocol: ApplicationProtocol;

  /**
   * The device attributes. For example HDLC address, password and other driver-specific attributes.
   *
   * @generated from field: map<string, io.clbs.openhes.pbdriver.AttributeValue> device_attributes = 3;
   */
  deviceAttributes: { [key: string]: AttributeValue };
};

/**
 * Describes the message io.clbs.openhes.pbdriver.DeviceConnectionInfo.
 * Use `create(DeviceConnectionInfoSchema)` to create a new message.
 */
export const DeviceConnectionInfoSchema: GenMessage<DeviceConnectionInfo> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 50);

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.pbdriver.ListOfModemInfo
 */
export type ListOfModemInfo = Message<"io.clbs.openhes.pbdriver.ListOfModemInfo"> & {
  /**
   * @generated from field: repeated io.clbs.openhes.pbdriver.ModemInfo items = 1;
   */
  items: ModemInfo[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ListOfModemInfo.
 * Use `create(ListOfModemInfoSchema)` to create a new message.
 */
export const ListOfModemInfoSchema: GenMessage<ListOfModemInfo> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 51);

/**
 * Addon for DB
 *
 * @generated from message io.clbs.openhes.pbdriver.ListOfConnectionInfo
 */
export type ListOfConnectionInfo = Message<"io.clbs.openhes.pbdriver.ListOfConnectionInfo"> & {
  /**
   * @generated from field: repeated io.clbs.openhes.pbdriver.DeviceConnectionInfo items = 1;
   */
  items: DeviceConnectionInfo[];
};

/**
 * Describes the message io.clbs.openhes.pbdriver.ListOfConnectionInfo.
 * Use `create(ListOfConnectionInfoSchema)` to create a new message.
 */
export const ListOfConnectionInfoSchema: GenMessage<ListOfConnectionInfo> = /*@__PURE__*/
  messageDesc(file_pbdriver_models, 52);

/**
 * Parity types
 *
 * @generated from enum io.clbs.openhes.pbdriver.SerialConfigParity
 */
export enum SerialConfigParity {
  /**
   * No parity
   *
   * @generated from enum value: PARITY_NONE = 0;
   */
  PARITY_NONE = 0,

  /**
   * Even parity
   *
   * @generated from enum value: PARITY_EVEN = 1;
   */
  PARITY_EVEN = 1,

  /**
   * Odd parity
   *
   * @generated from enum value: PARITY_ODD = 2;
   */
  PARITY_ODD = 2,

  /**
   * Mark parity
   *
   * @generated from enum value: PARITY_MARK = 3;
   */
  PARITY_MARK = 3,

  /**
   * Space parity
   *
   * @generated from enum value: PARITY_SPACE = 4;
   */
  PARITY_SPACE = 4,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.SerialConfigParity.
 */
export const SerialConfigParitySchema: GenEnum<SerialConfigParity> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 0);

/**
 * Baud rate types
 *
 * @generated from enum io.clbs.openhes.pbdriver.SerialConfigBaudRate
 */
export enum SerialConfigBaudRate {
  /**
   * 110 baud
   *
   * @generated from enum value: BAUD_RATE_110 = 0;
   */
  BAUD_RATE_110 = 0,

  /**
   * 300 baud
   *
   * @generated from enum value: BAUD_RATE_300 = 1;
   */
  BAUD_RATE_300 = 1,

  /**
   * 600 baud
   *
   * @generated from enum value: BAUD_RATE_600 = 2;
   */
  BAUD_RATE_600 = 2,

  /**
   * 1200 baud
   *
   * @generated from enum value: BAUD_RATE_1200 = 3;
   */
  BAUD_RATE_1200 = 3,

  /**
   * 2400 baud
   *
   * @generated from enum value: BAUD_RATE_2400 = 4;
   */
  BAUD_RATE_2400 = 4,

  /**
   * 4800 baud
   *
   * @generated from enum value: BAUD_RATE_4800 = 5;
   */
  BAUD_RATE_4800 = 5,

  /**
   * 9600 baud
   *
   * @generated from enum value: BAUD_RATE_9600 = 6;
   */
  BAUD_RATE_9600 = 6,

  /**
   * 14400 baud
   *
   * @generated from enum value: BAUD_RATE_14400 = 7;
   */
  BAUD_RATE_14400 = 7,

  /**
   * 19200 baud
   *
   * @generated from enum value: BAUD_RATE_19200 = 8;
   */
  BAUD_RATE_19200 = 8,

  /**
   * 38400 baud
   *
   * @generated from enum value: BAUD_RATE_38400 = 9;
   */
  BAUD_RATE_38400 = 9,

  /**
   * 57600 baud
   *
   * @generated from enum value: BAUD_RATE_57600 = 10;
   */
  BAUD_RATE_57600 = 10,

  /**
   * 115200 baud
   *
   * @generated from enum value: BAUD_RATE_115200 = 11;
   */
  BAUD_RATE_115200 = 11,

  /**
   * 230400 baud
   *
   * @generated from enum value: BAUD_RATE_230400 = 12;
   */
  BAUD_RATE_230400 = 12,

  /**
   * 460800 baud
   *
   * @generated from enum value: BAUD_RATE_460800 = 13;
   */
  BAUD_RATE_460800 = 13,

  /**
   * 921600 baud
   *
   * @generated from enum value: BAUD_RATE_921600 = 14;
   */
  BAUD_RATE_921600 = 14,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.SerialConfigBaudRate.
 */
export const SerialConfigBaudRateSchema: GenEnum<SerialConfigBaudRate> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 1);

/**
 * Data bits types
 *
 * @generated from enum io.clbs.openhes.pbdriver.SerialConfigDataBits
 */
export enum SerialConfigDataBits {
  /**
   * 5 data bits
   *
   * @generated from enum value: DATA_BITS_5 = 0;
   */
  DATA_BITS_5 = 0,

  /**
   * 6 data bits
   *
   * @generated from enum value: DATA_BITS_6 = 1;
   */
  DATA_BITS_6 = 1,

  /**
   * 7 data bits
   *
   * @generated from enum value: DATA_BITS_7 = 2;
   */
  DATA_BITS_7 = 2,

  /**
   * 8 data bits
   *
   * @generated from enum value: DATA_BITS_8 = 3;
   */
  DATA_BITS_8 = 3,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.SerialConfigDataBits.
 */
export const SerialConfigDataBitsSchema: GenEnum<SerialConfigDataBits> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 2);

/**
 * Stop bits types
 *
 * @generated from enum io.clbs.openhes.pbdriver.SerialConfigStopBits
 */
export enum SerialConfigStopBits {
  /**
   * 1 stop bit
   *
   * @generated from enum value: STOP_BITS_1 = 0;
   */
  STOP_BITS_1 = 0,

  /**
   * 1.5 stop bits
   *
   * @generated from enum value: STOP_BITS_1_5 = 1;
   */
  STOP_BITS_1_5 = 1,

  /**
   * 2 stop bits
   *
   * @generated from enum value: STOP_BITS_2 = 2;
   */
  STOP_BITS_2 = 2,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.SerialConfigStopBits.
 */
export const SerialConfigStopBitsSchema: GenEnum<SerialConfigStopBits> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 3);

/**
 * Job priorities
 *
 * @generated from enum io.clbs.openhes.pbdriver.JobPriority
 */
export enum JobPriority {
  /**
   * The lowest priority
   *
   * @generated from enum value: JOB_PRIORITY_0 = 0;
   */
  JOB_PRIORITY_0 = 0,

  /**
   * The priority 1
   *
   * @generated from enum value: JOB_PRIORITY_1 = 1;
   */
  JOB_PRIORITY_1 = 1,

  /**
   * The priority 2
   *
   * @generated from enum value: JOB_PRIORITY_2 = 2;
   */
  JOB_PRIORITY_2 = 2,

  /**
   * The priority 3
   *
   * @generated from enum value: JOB_PRIORITY_3 = 3;
   */
  JOB_PRIORITY_3 = 3,

  /**
   * The priority 4
   *
   * @generated from enum value: JOB_PRIORITY_4 = 4;
   */
  JOB_PRIORITY_4 = 4,

  /**
   * The priority 5
   *
   * @generated from enum value: JOB_PRIORITY_5 = 5;
   */
  JOB_PRIORITY_5 = 5,

  /**
   * The priority 6
   *
   * @generated from enum value: JOB_PRIORITY_6 = 6;
   */
  JOB_PRIORITY_6 = 6,

  /**
   * The priority 7
   *
   * @generated from enum value: JOB_PRIORITY_7 = 7;
   */
  JOB_PRIORITY_7 = 7,

  /**
   * The highest priority
   *
   * @generated from enum value: JOB_PRIORITY_8 = 8;
   */
  JOB_PRIORITY_8 = 8,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.JobPriority.
 */
export const JobPrioritySchema: GenEnum<JobPriority> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 4);

/**
 * Attribute types
 *
 * @generated from enum io.clbs.openhes.pbdriver.AttributeType
 */
export enum AttributeType {
  /**
   * Integer attribute type
   *
   * @generated from enum value: ATTRIBUTE_TYPE_INT = 0;
   */
  INT = 0,

  /**
   * String attribute type
   *
   * @generated from enum value: ATTRIBUTE_TYPE_STRING = 1;
   */
  STRING = 1,

  /**
   * Double attribute type
   *
   * @generated from enum value: ATTRIBUTE_TYPE_DOUBLE = 2;
   */
  DOUBLE = 2,

  /**
   * Binary attribute type
   *
   * @generated from enum value: ATTRIBUTE_TYPE_BINARY = 3;
   */
  BINARY = 3,

  /**
   * Date/time attribute type, stored as integer (UNIX timestamp)
   *
   * @generated from enum value: ATTRIBUTE_TYPE_TIMESTAMP = 4;
   */
  TIMESTAMP = 4,

  /**
   * Date/time attribute type, stored as string in ISO-8601
   *
   * @generated from enum value: ATTRIBUTE_TYPE_TIMESTAMP_TZ = 5;
   */
  TIMESTAMP_TZ = 5,

  /**
   * Bool attribute type
   *
   * @generated from enum value: ATTRIBUTE_TYPE_BOOL = 6;
   */
  BOOL = 6,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.AttributeType.
 */
export const AttributeTypeSchema: GenEnum<AttributeType> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 5);

/**
 * Action types
 *
 * @generated from enum io.clbs.openhes.pbdriver.ActionType
 */
export enum ActionType {
  /**
   * Get billing value, for example instantaneous values. The action covers specific register.
   *
   * @generated from enum value: ACTION_TYPE_GET_REGISTER = 0;
   */
  GET_REGISTER = 0,

  /**
   * Get periodical profile, for example load-profile. The action covers specific profile column.
   *
   * @generated from enum value: ACTION_TYPE_GET_PERIODICAL_PROFILE = 1;
   */
  GET_PERIODICAL_PROFILE = 1,

  /**
   * Get non-periodical profile, for example daily profile or monthly billing registers. The action covers specific profile column and or specific billing register.
   *
   * @generated from enum value: ACTION_TYPE_GET_IRREGULAR_PROFILE = 2;
   */
  GET_IRREGULAR_PROFILE = 2,

  /**
   * Get event log. The action covers specific event log.
   *
   * @generated from enum value: ACTION_TYPE_GET_EVENTS = 3;
   */
  GET_EVENTS = 3,

  /**
   * Get clock. The action returns time in UTC.
   *
   * @generated from enum value: ACTION_TYPE_GET_CLOCK = 10;
   */
  GET_CLOCK = 10,

  /**
   * Synchornize clock. The action synchronizes the time in the device, it can forcefully set it if force attribute is set.
   *
   * @generated from enum value: ACTION_TYPE_SYNC_CLOCK = 11;
   */
  SYNC_CLOCK = 11,

  /**
   * Get relay state. The action covers single relay.
   *
   * @generated from enum value: ACTION_TYPE_GET_RELAY_STATE = 20;
   */
  GET_RELAY_STATE = 20,

  /**
   * Set relay state. The action covers single relay.
   *
   * @generated from enum value: ACTION_TYPE_SET_RELAY_STATE = 21;
   */
  SET_RELAY_STATE = 21,

  /**
   * Get disconnector state. The action covers single disconnector if multiple disconnectors are present in the device.
   *
   * @generated from enum value: ACTION_TYPE_GET_DISCONNECTOR_STATE = 22;
   */
  GET_DISCONNECTOR_STATE = 22,

  /**
   * Set disconnector state. The action covers single relay. The action covers single disconnector if multiple disconnectors are present in the device.
   *
   * @generated from enum value: ACTION_TYPE_SET_DISCONNECTOR_STATE = 23;
   */
  SET_DISCONNECTOR_STATE = 23,

  /**
   * Get time-of-use table.
   *
   * @generated from enum value: ACTION_TYPE_GET_TOU = 24;
   */
  GET_TOU = 24,

  /**
   * Set time-of-use table.
   *
   * @generated from enum value: ACTION_TYPE_SET_TOU = 25;
   */
  SET_TOU = 25,

  /**
   * Get limiter settings. The action covers single limiter.
   *
   * @generated from enum value: ACTION_TYPE_GET_LIMITER = 26;
   */
  GET_LIMITER = 26,

  /**
   * Set limiter settings. The action covers single limiter.
   *
   * @generated from enum value: ACTION_TYPE_SET_LIMITER = 27;
   */
  SET_LIMITER = 27,

  /**
   * Reseet billing period.
   *
   * @generated from enum value: ACTION_TYPE_RESET_BILLING_PERIOD = 40;
   */
  RESET_BILLING_PERIOD = 40,

  /**
   * Start firmware update. The action updates starts FW upgrade procedure.
   *
   * @generated from enum value: ACTION_TYPE_FW_UPDATE = 50;
   */
  FW_UPDATE = 50,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.ActionType.
 */
export const ActionTypeSchema: GenEnum<ActionType> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 6);

/**
 * Result codes related to job actions
 *
 * @generated from enum io.clbs.openhes.pbdriver.ActionResultCode
 */
export enum ActionResultCode {
  /**
   * The action has been completed successfully.
   *
   * @generated from enum value: ERROR_CODE_ACTION_OK = 0;
   */
  ERROR_CODE_ACTION_OK = 0,

  /**
   * The action is not supported by the driver (or device).
   *
   * @generated from enum value: ERROR_CODE_ACTION_UNSUPPORTED = 1;
   */
  ERROR_CODE_ACTION_UNSUPPORTED = 1,

  /**
   * The action is pending.
   *
   * @generated from enum value: ERROR_CODE_ACTION_PENDING = 3;
   */
  ERROR_CODE_ACTION_PENDING = 3,

  /**
   * The action failed.
   *
   * @generated from enum value: ERROR_CODE_ACTION_ERROR = 5;
   */
  ERROR_CODE_ACTION_ERROR = 5,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.ActionResultCode.
 */
export const ActionResultCodeSchema: GenEnum<ActionResultCode> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 7);

/**
 * Error codes related to jobs
 *
 * @generated from enum io.clbs.openhes.pbdriver.JobErrorCode
 */
export enum JobErrorCode {
  /**
   * The job has been completed successfully.
   *
   * @generated from enum value: JOB_ERROR_CODE_NONE = 0;
   */
  NONE = 0,

  /**
   * There is no free slot in the driver to handle the job; the job shall be send again later.
   *
   * @generated from enum value: JOB_ERROR_CODE_BUSY = 1;
   */
  BUSY = 1,

  /**
   * The job failed, the retry will be attempted.
   *
   * @generated from enum value: JOB_ERROR_CODE_ERROR = 5;
   */
  ERROR = 5,

  /**
   * This should never happen! It means that the same job is currently being processed by the driver and it was sent to the driver mutliple times which would mean that there is a bug.
   *
   * @generated from enum value: JOB_ERROR_CODE_ALREADY_EXISTS = 8;
   */
  ALREADY_EXISTS = 8,

  /**
   * The job failed, the retry will NOT be attempted.
   *
   * @generated from enum value: JOB_ERROR_CODE_FATAL = 9;
   */
  FATAL = 9,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.JobErrorCode.
 */
export const JobErrorCodeSchema: GenEnum<JobErrorCode> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 8);

/**
 * Error codes
 *
 * @generated from enum io.clbs.openhes.pbdriver.ErrorCode
 */
export enum ErrorCode {
  /**
   * No error
   *
   * @generated from enum value: ERROR_CODE_OK = 0;
   */
  OK = 0,

  /**
   * Generic error
   *
   * @generated from enum value: ERROR_CODE_ERROR = 4;
   */
  ERROR = 4,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.ErrorCode.
 */
export const ErrorCodeSchema: GenEnum<ErrorCode> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 9);

/**
 * Connection types
 *
 * @generated from enum io.clbs.openhes.pbdriver.CommunicationType
 */
export enum CommunicationType {
  /**
   * The communication is done via direct TCP/IP.
   *
   * @generated from enum value: COMMUNICATION_TYPE_TCPIP = 0;
   */
  TCPIP = 0,

  /**
   * The communication is done via phone line (modem).
   *
   * @generated from enum value: COMMUNICATION_TYPE_MODEM_POOL = 1;
   */
  MODEM_POOL = 1,

  /**
   * The communication is done via direct serial line.
   *
   * @generated from enum value: COMMUNICATION_TYPE_SERIAL_LINE_DIRECT = 2;
   */
  SERIAL_LINE_DIRECT = 2,

  /**
   * The communication is done via controller-serial line (Moxa).
   *
   * @generated from enum value: COMMUNICATION_TYPE_SERIAL_LINE_MOXA = 3;
   */
  SERIAL_LINE_MOXA = 3,

  /**
   * The communication is passive, the driver is a service that listens on a port (DLMS devices in push mode) or a service that implements a subscriber to a message queue (e.g. MQTT).
   *
   * @generated from enum value: COMMUNICATION_TYPE_LISTENING = 99;
   */
  LISTENING = 99,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.CommunicationType.
 */
export const CommunicationTypeSchema: GenEnum<CommunicationType> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 10);

/**
 * Data link protocols
 *
 * @generated from enum io.clbs.openhes.pbdriver.DataLinkProtocol
 */
export enum DataLinkProtocol {
  /**
   * The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_IEC_62056_21 = 0;
   */
  LINKPROTO_IEC_62056_21 = 0,

  /**
   * The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_HDLC = 1;
   */
  LINKPROTO_HDLC = 1,

  /**
   * The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
   *
   * @generated from enum value: LINKPROTO_COSEM_WRAPPER = 2;
   */
  LINKPROTO_COSEM_WRAPPER = 2,

  /**
   * The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
   *
   * @generated from enum value: LINKPROTO_MODBUS = 3;
   */
  LINKPROTO_MODBUS = 3,

  /**
   * The M-Bus protocol. It shall be used for M-Bus application protocol.
   *
   * @generated from enum value: LINKPROTO_MBUS = 4;
   */
  LINKPROTO_MBUS = 4,

  /**
   * The data link protocol is not applicable. It's useful for listening communication type.
   *
   * @generated from enum value: LINKPROTO_NOT_APPLICABLE = 99;
   */
  LINKPROTO_NOT_APPLICABLE = 99,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.DataLinkProtocol.
 */
export const DataLinkProtocolSchema: GenEnum<DataLinkProtocol> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 11);

/**
 * Application protocols
 *
 * @generated from enum io.clbs.openhes.pbdriver.ApplicationProtocol
 */
export enum ApplicationProtocol {
  /**
   * The IEC 62056-21 (IEC-61107, VDEW) protocol.
   *
   * @generated from enum value: APPPROTO_IEC_62056_21 = 0;
   */
  APPPROTO_IEC_62056_21 = 0,

  /**
   * The DLMS short-name protocol.
   *
   * @generated from enum value: APPPROTO_DLMS_SN = 1;
   */
  APPPROTO_DLMS_SN = 1,

  /**
   * The DLMS logical-name protocol.
   *
   * @generated from enum value: APPPROTO_DLMS_LN = 2;
   */
  APPPROTO_DLMS_LN = 2,

  /**
   * The SCTM protocol.
   *
   * @generated from enum value: APPPROTO_SCTM = 3;
   */
  APPPROTO_SCTM = 3,

  /**
   * The LIS200 protocol.
   *
   * @generated from enum value: APPPROTO_LIS200 = 4;
   */
  APPPROTO_LIS200 = 4,

  /**
   * The ANSI C12 protocol.
   *
   * @generated from enum value: APPPROTO_ANSI_C12 = 5;
   */
  APPPROTO_ANSI_C12 = 5,

  /**
   * The MQTT protocol.
   *
   * @generated from enum value: APPPROTO_MQTT = 6;
   */
  APPPROTO_MQTT = 6,
}

/**
 * Describes the enum io.clbs.openhes.pbdriver.ApplicationProtocol.
 */
export const ApplicationProtocolSchema: GenEnum<ApplicationProtocol> = /*@__PURE__*/
  enumDesc(file_pbdriver_models, 12);

