// Editions version of proto3 file
edition = "2023";
package io.clbs.openhes.models.acquisition;

option go_package = "github.com/cybroslabs/hes-2-apis/gen/go/acquisition";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "common/metadata.proto";

// Job priorities
enum JobPriority {
    // The lowest priority
    JOB_PRIORITY_0 = 0;
    // The priority 1
    JOB_PRIORITY_1 = 1;
    // The priority 2
    JOB_PRIORITY_2 = 2;
    // The priority 3
    JOB_PRIORITY_3 = 3;
    // The priority 4
    JOB_PRIORITY_4 = 4;
    // The priority 5
    JOB_PRIORITY_5 = 5;
    // The priority 6
    JOB_PRIORITY_6 = 6;
    // The priority 7
    JOB_PRIORITY_7 = 7;
    // The highest priority
    JOB_PRIORITY_8 = 8;
}

// Sub-message containing job parameters
message JobSettings {
    int64 max_duration                   = 1;  // Maximum duration of the job attempt in miliseconds. This is related to the real time for the driver.
    JobPriority priority                 = 2;  // Priority of the job.
    repeated int32 attempts              = 3;  // Maximum number of attempts, 1 is the minimum.
    int64 retry_delay                    = 4;  // Delay in miliseconds between two attempts.
    uint64 defer_start                   = 5;  // Number of miliseconds to wait before starting the job.
    google.protobuf.Timestamp expires_at = 6;  // The timestamp when the job expires.
}

// Sub-message containing job action specification
message JobAction {
    string action_id                       = 1;  // The action identifier.
    map<string, AttributeValue> attributes = 2;  // The action attributes.
    oneof action {
        ActionGetRegister get_register                    = 3;   // The get register action specification.
        ActionGetPeriodicalProfile get_periodical_profile = 4;   // The get periodical profile action specification.
        ActionGetIrregularProfile get_irregular_profile   = 5;   // The get irregular profile action specification.
        ActionGetEvents get_events                        = 6;   // The get events action specification.
        ActionGetClock get_clock                          = 7;   // The get clock action specification.
        ActionSyncClock sync_clock                        = 8;   // The sync clock action specification.
        ActionGetRelayState get_relay_state               = 9;   // The get relay state action specification.
        ActionSetRelayState set_relay_state               = 10;  // The set relay state action specification.
        ActionGetDisconnectorState get_disconnector_state = 11;  // The get disconnector state action specification.
        ActionSetDisconnectorState set_disconnector_state = 12;  // The set disconnector state action specification.
        ActionGetTou get_tou                              = 13;  // The get tou action specification.
        ActionSetTou set_tou                              = 14;  // The set tou action specification.
        ActionGetLimiter get_limiter                      = 15;  // The get limiter action specification.
        ActionSetLimiter set_limiter                      = 16;  // The set limiter action specification.
        ActionResetBillingPeriod reset_billing_period     = 17;  // The reset billing period action specification.
        ActionFwUpdate fw_update                          = 18;  // The firmware update action specification.
    }
}

message CreateBulkRequest2 {
    // @gqltype: UUID
    string id             = 1;  // The bulk identifier.
    string correlation_id = 2;  // The correlation identifier, e.g. to define relation to non-homogenous group.
    string driver_type    = 3;  // The device (driver) type.
    oneof device {
        ListOfJobDeviceId devices      = 4;  // The list of devices in the bulk.
        ListOfJobDevice custom_devices = 5;  // The list of custom devices in the bulk.
    }
    JobSettings settings       = 6;  // The bulk-shared job settings.
    repeated JobAction actions = 7;  // The list actions to be executed.
    string webhook_url         = 8;  // The webhook URL to call when the bulk is completed.
}

// Sub-message - holds the bulk job specification.
message BulkSpec {
    string bulk_id                 = 1;  // The bulk identifier.
    string correlation_id          = 2;  // The correlation identifier, e.g. to define relation to non-homogenous group.
    string driver_type             = 4;  // The device (driver) type.
    repeated JobDevice devices     = 5;  // The list of devices in the bulk.
    JobSettings settings           = 6;  // The bulk-shared job settings.
    repeated JobAction job_actions = 7;  // The list actions to be executed.
    string webhook_url             = 8;  // The webhook URL to call when the bulk is completed.
    string user_id                 = 9;  // The user identifier.
}

message ListOfJobDevice {
    repeated JobDevice list = 5;  // The list of devices in the bulk.
}

message ListOfJobDeviceId {
    repeated JobDeviceId list = 5;  // The list of devices in the bulk.
}

message JobDeviceId {
    string id        = 1;  // The device's job identifier within the parent bulk.
    string device_id = 2;  // The device identifier.
}

// Sub-message representing a single job-device info.
message JobDevice {
    string id                                     = 1;  // The device (job) identifier.
    string device_id                              = 2;  // The device identifier. If set then all below is loaded from the device registry.
    string external_id                            = 3;  // The external identifier.
    map<string, AttributeValue> device_attributes = 4;  // The connection attributes to the device.
    repeated ConnectionInfo connection_info       = 5;  // The conenction (device) parameters.
    ApplicationProtocol app_protocol              = 6;  // The application protocol.
    string timezone                               = 7;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

// Sub-message containing modem connection info
message ModemInfo {
    string id              = 1;   // The modem identifier. It is automatically generated during creation.
    string name            = 2;   // The name of the modem.
    string at_init         = 3;   // The modem initialization command.
    string at_test         = 4;   // The modem test command.
    string at_config       = 5;   // The modem configuration command.
    string at_dial         = 6;   // The modem dial command.
    string at_hangup       = 7;   // The modem hangup command.
    string at_escape       = 8;   // The modem escape command.
    bool at_dsr            = 9;   // The modem DSR command.
    uint32 connect_timeout = 10;  // The modem connection timeout.
    // The modem connection description.
    oneof modem_connection {
        ConnectionTypeDirectTcpIp tcpip = 11;  // The TCP connection type. The modem has either TCP or there is a IP-to-serial converter which handles the serial configuration so no additional serial configuration is needed.
        // This is then reserved for future connection options.
    }
}

// Parity types
enum SerialConfigParity {
    // No parity
    PARITY_NONE = 0;
    // Even parity
    PARITY_EVEN = 1;
    // Odd parity
    PARITY_ODD = 2;
    // Mark parity
    PARITY_MARK = 3;
    // Space parity
    PARITY_SPACE = 4;
}

// Baud rate types
enum SerialConfigBaudRate {
    // 110 baud
    BAUD_RATE_110 = 0;
    // 300 baud
    BAUD_RATE_300 = 1;
    // 600 baud
    BAUD_RATE_600 = 2;
    // 1200 baud
    BAUD_RATE_1200 = 3;
    // 2400 baud
    BAUD_RATE_2400 = 4;
    // 4800 baud
    BAUD_RATE_4800 = 5;
    // 9600 baud
    BAUD_RATE_9600 = 6;
    // 14400 baud
    BAUD_RATE_14400 = 7;
    // 19200 baud
    BAUD_RATE_19200 = 8;
    // 38400 baud
    BAUD_RATE_38400 = 9;
    // 57600 baud
    BAUD_RATE_57600 = 10;
    // 115200 baud
    BAUD_RATE_115200 = 11;
    // 230400 baud
    BAUD_RATE_230400 = 12;
    // 460800 baud
    BAUD_RATE_460800 = 13;
    // 921600 baud
    BAUD_RATE_921600 = 14;
}

// Data bits types
enum SerialConfigDataBits {
    // 5 data bits
    DATA_BITS_5 = 0;
    // 6 data bits
    DATA_BITS_6 = 1;
    // 7 data bits
    DATA_BITS_7 = 2;
    // 8 data bits
    DATA_BITS_8 = 3;
}

// Stop bits types
enum SerialConfigStopBits {
    // 1 stop bit
    STOP_BITS_1 = 0;
    // 1.5 stop bits
    STOP_BITS_1_5 = 1;
    // 2 stop bits
    STOP_BITS_2 = 2;
}

// Sub-message containing serial port configuration
message SerialConfig {
    SerialConfigBaudRate baud_rate = 1;  // The baud rate.
    SerialConfigParity parity      = 2;  // The parity.
    SerialConfigDataBits data_bits = 3;  // The data bits.
    SerialConfigStopBits stop_bits = 4;  // The stop bits.
}

// Sub-message containing connection info
message ConnectionInfo {
    // The entrypoint connection description. It can be either direct TCP, a modem from a pool or a direct serial line over IP (using IP-to-serial converter).
    oneof connection {
        ConnectionTypeDirectTcpIp tcpip               = 1;  // The TCP connection type.
        ConnectionTypeModemPool modem_pool            = 2;  // The phone connection type.
        ConnectionTypeControlledSerial serial_over_ip = 3;  // The serial over IP connection type.
    }
    DataLinkProtocol link_protocol = 4;  // The data link protocol.
    string custom_grouping_id      = 5;  // The custom group ID to link jobs together. If not set then jobs are grouped by group-key defined based on the connection type.
}

// Sub-message containing connection info for TCP connection type
message ConnectionTypeDirectTcpIp {
    string host   = 1;  // The host name or IP address of the device to connect to.
    uint32 port   = 2;  // The TCP port number of the device to connect to.
    int32 timeout = 3;  // The timeout in miliseconds for the connection.
}

// Sub-message containing connection info for phone line (modem) connection type
message ConnectionTypeModemPool {
    // The phone number of the device to connect to.
    string number = 1;
    // The modem pool identifier. The pool is a group of modems that can be used to connect to the device. Final modem is selected by the Taskmaster at the time of the job start.
    string pool_id = 2;
    // The modem device assigned to the job. This is filled only and only when the connection type is modem. The value is assigned by the Taskmaster when to job is being started. Driver is required to use this modem device to connect to the meter only and only for the time of this job!
    ModemInfo modem = 4;
}

message ConnectionTypeSerialDirect {
    string host = 1;  // The host name or IP address of the device to connect to.
    uint32 port = 2;  // The TCP port number of the device to connect to.
}

// Sub-message containing connection info for controlled-serial line (Moxa) connection type
message ConnectionTypeSerialMoxa {
    string host        = 1;  // The host name or IP address of the device to connect to.
    uint32 dataPort    = 2;  // The TCP port number of the device to connect to - data port.
    uint32 commandPort = 3;  // The TCP port number of the device to connect to - command port.
}

// Connection types
enum CommunicationType {
    // The communication is done via direct TCP/IP.
    COMMUNICATION_TYPE_TCPIP = 0;
    // The communication is done via phone line (modem).
    COMMUNICATION_TYPE_MODEM_POOL = 1;
    // The communication is done via direct serial line.
    COMMUNICATION_TYPE_SERIAL_LINE_DIRECT = 2;
    // The communication is done via controller-serial line (Moxa).
    COMMUNICATION_TYPE_SERIAL_LINE_MOXA = 3;

    // The communication is passive, the driver is a service that listens on a port (DLMS devices in push mode) or a service that implements a subscriber to a message queue (e.g. MQTT).
    COMMUNICATION_TYPE_LISTENING = 99;
}

// Data link protocols
enum DataLinkProtocol {
    // The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
    LINKPROTO_IEC_62056_21 = 0;
    // The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
    LINKPROTO_HDLC = 1;
    // The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
    LINKPROTO_COSEM_WRAPPER = 2;
    // The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
    LINKPROTO_MODBUS = 3;
    // The M-Bus protocol. It shall be used for M-Bus application protocol.
    LINKPROTO_MBUS = 4;

    // The data link protocol is not applicable. It's useful for listening communication type.
    LINKPROTO_NOT_APPLICABLE = 99;
}

// Application protocols
enum ApplicationProtocol {
    // The IEC 62056-21 (IEC-61107, VDEW) protocol.
    APPPROTO_IEC_62056_21 = 0;
    // The DLMS short-name protocol.
    APPPROTO_DLMS_SN = 1;
    // The DLMS logical-name protocol.
    APPPROTO_DLMS_LN = 2;
    // The SCTM protocol.
    APPPROTO_SCTM = 3;
    // The LIS200 protocol.
    APPPROTO_LIS200 = 4;
    // The ANSI C12 protocol.
    APPPROTO_ANSI_C12 = 5;
    // The MQTT protocol.
    APPPROTO_MQTT = 6;
}

// Sub-message containing destription for one application protocol, e.g. DLMS_SN.
message ApplicationProtocolTemplate {
    // Unique identifier of the application protocol.
    string id = 1;
    // The application protocol.
    ApplicationProtocol protocol = 2;
    // The list of attribute definitions for the protocol.
    repeated AttributeDefinition attributes = 3;
}

// Sub-message containing destription for one data link protocol, e.g. HDLC.
message DataLinkTemplate {
    // The data link protocol.
    DataLinkProtocol link_protocol = 1;
    // The list of application protocol identifiers supported by the driver.
    repeated ApplicationProtocol app_protocol_refs = 2;
    // The list of attribute definitions related to given data link type (see link_protocol property) and all those will be instantiated for each device.
    repeated AttributeDefinition attributes = 3;
}

// Sub-message containing destription for one communication type, e.g. TCP/IP.
message CommunicationTemplate {
    // The type of the communication.
    CommunicationType type = 1;
    // The list of data link protocols and their app protocols supported by the driver.
    repeated DataLinkTemplate datalinks = 2;
}

// Sub-message containing access level definition
message AccessLevelTemplate {
    string id   = 1;  // The access level identifier, such as "1", "G", "16" or similar.
    string name = 2;  // The access level name. Should be in English and unique for given driver, e.g. "Management", "Public".
}

// Sub-message in driver negotiation request
message DriverTemplates {
    // The templates of the communication options. Every template represents an option how the drivers allows to communicate. The driver can support multiple communication templates.
    repeated CommunicationTemplate communication_templates = 1;
    // The templates of the application protocols supported by the driver.
    repeated ApplicationProtocolTemplate app_protocols = 2;
    // The templates of the job actions for all supported action types. It must contain every action type supported by the driver once and only once.
    repeated JobActionAttributes action_attributes = 3;
    // The templates of the access levels supported by the driver.
    repeated AccessLevelTemplate access_templates = 4;
    // The templates of the job actions constraints.
    JobActionContraints action_constraints = 5;
}

// Driver -> Taskmaster job/action progress update message
message ProgressUpdate {
    // The oneof field containing the progress update data - either for job or for action.
    oneof progress {
        JobProgressUpdate job       = 1;  // The job progress update data. It shall be called once and only once for each job. It shall be also called as the last message in the stream; other updates will be ignored after this.
        ActionProgressUpdate action = 2;  // The action progress update data. It shall be called for each action in the job.
    }
}

// Sub-message containing action progress update
message ActionProgressUpdate {
    string job_id         = 1;  // The job identifier.
    string action_id      = 2;  // The action identifier.
    ActionResultCode code = 3;  // The status related to the action.
    ActionData data       = 4;  // The action result data. Shall be empty if the code is not OK.
}

// Sub-message containing job progress update
message JobProgressUpdate {
    string job_id     = 1;  // The job identifier.
    JobErrorCode code = 2;  // The status related to the job and or action update message.
    int64 duration    = 3;  // The duration of the job in miliseconds.
}

// Sub-message containing action-based variant of data values
message ActionData {
    oneof data {
        google.protobuf.Empty nodata = 1;  // No data
        BillingValues billings       = 2;  // Register values
        ProfileValues profile        = 3;  // Profile values
    }
}

// Sub-message containing profile-typed values
message ProfileValues {
    int32 period                = 1;  // The period of the profile values.
    string unit                 = 2;  // The unit of the profile values.
    repeated ProfileBlok blocks = 3;  // The list of continuous profile blocks.
}

// Sub-message containing a single profile block
message ProfileBlok {
    google.protobuf.Timestamp start_timestamp = 1;  // The start timestamp of the block.
    repeated MeasuredValue values             = 2;  // The list of profile values. Values are ordered by timestamp.
}

// Sub-message containing billing-typed values
message BillingValues {
    repeated BillingValue values = 1;  // The list of register values.
}

// Sub-message containing billing-typed value
message BillingValue {
    google.protobuf.Timestamp timestamp = 1;  // The timestamp of the value.
    string unit                         = 2;  // The unit of the value.
    MeasuredValue value                 = 3;  // The value.
}

// Sub-message containing measured value
message MeasuredValue {
    int64 status   = 1;  // The status of the value.
    int32 exponent = 2;  // The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
    oneof value {
        double double_value                       = 3;  // The double-typed value.
        int64 int_value                           = 4;  // The integer-typed value.
        string str_value                          = 5;  // The string-typed value.
        google.protobuf.Timestamp timestamp_value = 6;  // The timestamp-typed value.
        string timestamp_tz_value                 = 7;  // The timestamp with timezone-typed value, stored as string in ISO-8601.
        bool bool_value                           = 8;  // The boolean-typed value.
    }
}

// Sub-message containing attribute definition
message AttributeDefinition {
    string name                  = 1;  // The name of the attribute.
    string description           = 2;  // The description of the attribute.
    AttributeType type           = 3;  // The type of the attribute.
    bool mandatory               = 4;  // The attribute is mandatory or not.
    AttributeValue default_value = 5;  // The default value of the attribute.
    map<string, string> options  = 6;  // Optional. The list of values (represented by keys) that can be set. The value is the human-readable description in English (translations are applies using i18 or similar framework outside of the templates). If no values is defined then any value is allowed.
}

// Sub-message containing job action attributes
message JobActionAttributes {
    // The type of action for which this instance of the template is defined.
    ActionType type = 1;
    // The template of the action attributes. It is represented as a list of attribute definitions.
    repeated AttributeDefinition attributes = 2;
}

// Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
message ConnectionTypeControlledSerial {
    // IP-to-serial converter description.
    oneof converter {
        ConnectionTypeSerialDirect direct = 1;  // The simple direct serial connection type.
        ConnectionTypeSerialMoxa moxa     = 2;  // The Moxa connection type.
        // TBA: Add Advanctech and other IP-to-serial converters.
    }
}

// Attribute types
enum AttributeType {
    // Integer attribute type
    ATTRIBUTE_TYPE_INT = 0;
    // String attribute type
    ATTRIBUTE_TYPE_STRING = 1;
    // Double attribute type
    ATTRIBUTE_TYPE_DOUBLE = 2;
    // Binary attribute type
    ATTRIBUTE_TYPE_BINARY = 3;
    // Date/time attribute type, stored as integer (UNIX timestamp)
    ATTRIBUTE_TYPE_TIMESTAMP = 4;
    // Date/time attribute type, stored as string in ISO-8601
    ATTRIBUTE_TYPE_TIMESTAMP_TZ = 5;
    // Bool attribute type
    ATTRIBUTE_TYPE_BOOL = 6;
}

// Action types
enum ActionType {
    // Get billing value, for example instantaneous values. The action covers specific register.
    ACTION_TYPE_GET_REGISTER = 0;
    // Get periodical profile, for example load-profile. The action covers specific profile column.
    ACTION_TYPE_GET_PERIODICAL_PROFILE = 1;
    // Get non-periodical profile, for example daily profile or monthly billing registers. The action covers specific profile column and or specific billing register.
    ACTION_TYPE_GET_IRREGULAR_PROFILE = 2;
    // Get event log. The action covers specific event log.
    ACTION_TYPE_GET_EVENTS = 3;

    // Get clock. The action returns time in UTC.
    ACTION_TYPE_GET_CLOCK = 10;
    // Synchornize clock. The action synchronizes the time in the device, it can forcefully set it if force attribute is set.
    ACTION_TYPE_SYNC_CLOCK = 11;

    // Get relay state. The action covers single relay.
    ACTION_TYPE_GET_RELAY_STATE = 20;
    // Set relay state. The action covers single relay.
    ACTION_TYPE_SET_RELAY_STATE = 21;

    // Get disconnector state. The action covers single disconnector if multiple disconnectors are present in the device.
    ACTION_TYPE_GET_DISCONNECTOR_STATE = 22;
    // Set disconnector state. The action covers single relay. The action covers single disconnector if multiple disconnectors are present in the device.
    ACTION_TYPE_SET_DISCONNECTOR_STATE = 23;

    // Get time-of-use table.
    ACTION_TYPE_GET_TOU = 24;
    // Set time-of-use table.
    ACTION_TYPE_SET_TOU = 25;

    // Get limiter settings. The action covers single limiter.
    ACTION_TYPE_GET_LIMITER = 26;
    // Set limiter settings. The action covers single limiter.
    ACTION_TYPE_SET_LIMITER = 27;

    // Reseet billing period.
    ACTION_TYPE_RESET_BILLING_PERIOD = 40;

    // Start firmware update. The action updates starts FW upgrade procedure.
    ACTION_TYPE_FW_UPDATE = 50;
}

// Sub-message containing get register action specification
message ActionGetRegister {
}

// Sub-message containing get periodical profile action specification
message ActionGetPeriodicalProfile {
    google.protobuf.Timestamp from = 1;  // The start timestamp of the profile.
    google.protobuf.Timestamp to   = 2;  // The end timestamp of the profile.
}

// Sub-message containing get irregular profile action specification
message ActionGetIrregularProfile {
    google.protobuf.Timestamp from = 1;  // The start timestamp of the profile.
    google.protobuf.Timestamp to   = 2;  // The end timestamp of the profile.
}

// Sub-message containing get events action specification
message ActionGetEvents {
    google.protobuf.Timestamp from = 1;  // The start timestamp of the profile.
    google.protobuf.Timestamp to   = 2;  // The end timestamp of the profile.
}

// Sub-message containing get clock action specification
message ActionGetClock {
}

// Sub-message containing sync clock action specification
message ActionSyncClock {
}

// Sub-message containing get relay state action specification
message ActionGetRelayState {
}

// Sub-message containing set relay state action specification
message ActionSetRelayState {
}

// Sub-message containing get disconnector state action specification
message ActionGetDisconnectorState {
}

// Sub-message containing set disconnector state action specification
message ActionSetDisconnectorState {
}

// Sub-message containing get tou action specification
message ActionGetTou {
}

// Sub-message containing set tou action specification
message ActionSetTou {
}

// Sub-message containing get limiter action specification
message ActionGetLimiter {
}

// Sub-message containing set limiter action specification
message ActionSetLimiter {
}

// Sub-message containing reset billing period action specification
message ActionResetBillingPeriod {
}

// Sub-message containing firmware update action specification
message ActionFwUpdate {
}

// Sub-message containing single attribute value specification
message AttributeValue {
    oneof value {
        string str_value    = 1;  // The string-typed value.
        int64 int_value     = 2;  // The integer-typed value.
        double double_value = 3;  // The double-typed value.
        bytes binary_value  = 4;  // The binary-typed value.
        bool bool_value     = 5;  // The boolean-typed value.
    }
}

// Result codes related to job actions
enum ActionResultCode {
    // The action has been completed successfully.
    ERROR_CODE_ACTION_OK = 0;
    // The action is not supported by the driver (or device).
    ERROR_CODE_ACTION_UNSUPPORTED = 1;
    // The action is pending.
    ERROR_CODE_ACTION_PENDING = 3;
    // The action failed.
    ERROR_CODE_ACTION_ERROR = 5;
}

// Error codes related to jobs
enum JobErrorCode {
    // The job has been completed successfully.
    JOB_ERROR_CODE_NONE = 0;
    // There is no free slot in the driver to handle the job; the job shall be send again later.
    JOB_ERROR_CODE_BUSY = 1;
    // The job failed, the retry will be attempted.
    JOB_ERROR_CODE_ERROR = 5;
    // This should never happen! It means that the same job is currently being processed by the driver and it was sent to the driver mutliple times which would mean that there is a bug.
    JOB_ERROR_CODE_ALREADY_EXISTS = 8;
    // The job failed, the retry will NOT be attempted.
    JOB_ERROR_CODE_FATAL = 9;
}

// Defines a mesasge as a list of strings.
message StringList {
    // The list of strings.
    repeated string items = 1;
}

// Sub-message containing constraints for job actions.
message JobActionContraints {
    // Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
    // Action: ACTION_TYPE_GET_REGISTER
    map<string, string> get_register_type_name = 1;
    // Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
    // See JobActionAttributes for the attribute definitions.
    // Action: ACTION_TYPE_GET_REGISTER
    map<string, StringList> get_register_type_attributes = 2;
}

// RestApi -> DataProxy
message CreateBulkRequest {
    BulkSpec spec                  = 1;  // The bulk-job spec.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

// Bulk statuses
enum BulkStatusCode {
    // The job is waiting in the queue
    BULK_STATUS_QUEUED = 0;
    // The job is running
    BULK_STATUS_RUNNING = 1;
    // The job is completed
    BULK_STATUS_COMPLETED = 2;
    // The job is cancelled
    BULK_STATUS_CANCELLED = 3;
    // The job has expired
    BULK_STATUS_EXPIRED = 4;
}

// Sub-message - holds the bulk job status.
message BulkStatus {
    BulkStatusCode status = 1;  // The job status.
    repeated BulkJob jobs = 2;  // The list of job statuses.
}

message BulkJob {
    string job_id    = 1;  // The job identifier.
    JobStatus status = 2;  // The job status.
}

// Sub-message containing job status info
message JobStatus {
    JobStatusCode status                  = 1;  // The status of the job.
    JobErrorCode code                     = 2;  // The error code of the job.
    repeated ActionResult results         = 3;  // The result data for all job actions.
    google.protobuf.Timestamp created_at  = 4;  // The creation timestamp of the job.
    google.protobuf.Timestamp started_at  = 5;  // The start timestamp of the job.
    google.protobuf.Timestamp finished_at = 6;  // The finish timestamp of the job.
    int32 attempts_done                   = 7;  // The number of attempts already done.
}

// DataProxy -> RestApi - the message holds the bulk info and it's status.
message Bulk {
    BulkSpec spec                  = 1;  // The bulk-job spec.
    BulkStatus status              = 2;  // The bulk-job status/data.
    common.MetadataFields metadata = 3;  // The metadata fields.
}

// DataProxy -> RestApi - the message holds list of bulks.
message ListOfBulk {
    repeated Bulk items = 1;  // The list of bulks.
}

// Taskmaster -> Driver start job request message
message StartJobsRequest {
    ConnectionInfo connection_info = 2;  // The connection info for the job.
    repeated StartJobData jobs     = 1;  // The list of jobs to be started with the same connection info.
}

// Sub-message containing job start request for single device
message StartJobData {
    map<string, AttributeValue> device_attributes = 1;  // The device attributes. For example HDLC address, password and other driver-specific attributes.
    string job_id                                 = 2;  // The job identifier.
    JobSettings job_settings               = 3;  // The job parameters.
    repeated JobAction job_actions                = 4;  // The list actions to be executed.
    ApplicationProtocol app_protocol              = 5;  // The application protocol.
    string timezone                               = 6;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

// Taskmaster -> Driver cancel job request message
message CancelJobRequest {
    string job_id = 1;  // The job identifier.
}

// Driver -> Taskmaster negotiate/health-check request message
message NegotiateRequest {
    // The driver version. The format is not defined. The driver itself is versioned by the docker image tags so this value shall be either the same (set during the image build) or any useful user-readable version string.
    string version = 1;
    // The port the driver's gRPC will listen on.
    uint32 listening_port = 2;
    // The technical/internal ID of the driver.
    string driver_type = 3;
    // The maximum number of concurrent jobs the driver can handle. The value 0 is not allowed, the maximum number respect typical_mem_usage not to overgrow the memory resources!
    int32 max_concurrent_jobs = 4;
    // The maximum cascade depth the driver can handle. Number 1 means that the driver cannot handle cascading jobs, 2 means that the driver can handle cascading jobs with one level of depth, etc.
    // The value 0 means that the driver can handle any number of cascading jobs.
    uint32 max_cascade_depth = 5;
    // The typical memory usage of the driver in MB.
    int32 typical_mem_usage = 6;
    // The connection and action templates.
    DriverTemplates templates = 7;
    // The display name of the driver. Must be in format '<manufacturer> <device_type> [<device_type_version>]'.
    // It must respect upper/lower characters.
    // The generic drivers, such as 'cybros labs generic', must be named as '<driver_company_name> generic'.
    //
    // Examples: 'Addax NP73E', 'cybros labs generic', 'Landis+Gyr S650 v2'
    string display_name = 8;
}

// Addon
message DeviceConnectionInfo {
    ConnectionInfo communication_unit             = 1;  // The unique identifier of the communication unit.
    ApplicationProtocol app_protocol              = 2;  // The application protocol to be used for the communication over the communication unit.
    map<string, AttributeValue> device_attributes = 3;  // The device attributes. For example HDLC address, password and other driver-specific attributes.
}

// Addon for DB
message ListOfModemInfo {
    repeated ModemInfo items = 1;
}

// Addon for DB
message ListOfConnectionInfo {
    repeated DeviceConnectionInfo items = 1;
}

// Job statuses
enum JobStatusCode {
    // The job is waiting in the queue
    JOB_STATUS_QUEUED = 0;
    // The job is running
    JOB_STATUS_RUNNING = 1;
    // The job is completed
    JOB_STATUS_COMPLETED = 2;
    // The job is failed
    JOB_STATUS_FAILED = 3;
    // The job is cancelled
    JOB_STATUS_CANCELLED = 4;
    // The job has expired
    JOB_STATUS_EXPIRED = 5;
}

// Sub-message containing action result for a single action.
message ActionResult {
    string action_id                    = 1;  // The action identifier.
    ActionResultCode status = 2;  // The status of the action.
    ActionData data         = 3;  // The action result data.
}

// API <-> Taskmaster request/response for system configuration
message SystemConfig {
    // The maximum number of replicas for the driver.
    //    0 represents no active replicas will run, effectively disabling acquisition
    //   >0 represents the maximum number of replicas per driver
    int32 max_replicas = 1;
    // The maximum number of cascade devices for the driver. Minimum is 1.
    int32 max_cascade_device_count = 2;
    // The maximum number of slots per driver
    //   -1 represents unlimited number of slots, effecticaly using maximum number of slots supported by driver
    //    0 represents no active slots will run, effectively disabling acquisition
    //   >0 represents the maximum number of slots per driver, the number of slots never exceeds the number of slots supported by driver
    int32 max_slots_per_driver = 3;
}

// Taskmaster -> Dataproxy job/action progress update message
message JobEventData {
    bytes job_id = 1;  // The job identifier.
}

// RestApi -> DriverRegistry - The communication unit specification.
message CreateCommunicationUnitRequest {
    CommunicationUnitSpec spec = 1;  // The communication unit specification.
}

// DriverRegistry -> RestApi - the message holds the information about the communication unit.
message ListOfCommunicationUnitSpec {
    repeated CommunicationUnitSpec items = 1;  // The communication unit specification.
}

message CommunicationUnit {
    CommunicationUnitSpec spec     = 1;  // The communication unit specification.
    common.MetadataFields metadata = 2;  // The metadata fields.
}

// Sub-message - the communication unit specification.
message CommunicationUnitSpec {
    string id                               = 1;  // The UUID of the communication unit.
    string external_id                      = 2;  // The external identifier of the communication unit.
    string name                             = 3;  // The name of the communication unit.
    ConnectionInfo connection_info = 4;  // The connection info.
}

// RestApi -> DriverRegistry - the request message to create a new device.
message CreateDeviceRequest {
    DeviceSpec spec = 1;  // The device specification.
}

// RestApi -> DriverRegistry - the request message to get the information about the device.
message GetDevicesRequest {
    string id          = 1;  // The UUID of the device.
    string external_id = 2;  // The external identifier of the device.
    string name        = 3;  // The name of the device.
}

// DriverRegistry -> RestApi - the message holds the information about the device.
message Device {
    DeviceSpec spec = 1;  // The device specification.
    // TODO: Add status
}

message ListOfDevice {
    repeated Device items = 1;  // The list of devices.
}

// Sub-message - the device specification.
message DeviceSpec {
    string id                                                = 1;  // The UUID of the device.
    string external_id                                       = 2;  // The external identifier of the device.
    string name                                              = 3;  // The name of the device.
    map<string, AttributeValue> attributes          = 4;  // The template of the action attributes. It is represented as a list of attribute definitions.
    repeated DeviceCommunicationUnit communication_unit_link = 5;  // The list of communication unit identifiers (and additional info) that set CUs usable to communicate with the device. It's an ordered set where the first element is the primary communication unit with the highest priority.
    string timezone                                          = 6;  // The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
}

// Sub-message that represents the device group.
message DeviceGroupSpec {
    string id                 = 1;  // The UUID of the device group.
    string external_id        = 2;  // The external identifier of the communication unit.
    string name               = 3;  // The name of the device group.
    repeated string device_id = 4;  // The list of device identifiers that are part of the group.
}

// RestApi -> DriverRegistry - the request message to get the information about the device group.
message CreateDeviceGroupRequest {
    DeviceGroupSpec spec = 1;  // The device group specification.
}

// DriverRegistry -> RestApi - the message holds the information about the device group.
message GetDeviceGroupsResponse {
    map<string, DeviceGroupOverviewSpec> groups = 1;  // The list of device groups.
}

message DeviceGroupOverviewSpec {
    string id          = 1;  // The UUID of the device group.
    string external_id = 2;  // The external identifier of the communication unit.
    string name        = 3;  // The name of the device group.
}

// DriverRegistry -> RestApi - the message holds the information about the device group.
message GetDeviceGroupResponse {
    DeviceGroupSpec spec = 1;  // The device group specification.
}

// RestApi -> DriverRegistry - the request message to add a new device to the device group.
message AddDevicesToGroupRequest {
    string group_id           = 1;  // The unique identifier of the device group.
    repeated string device_id = 2;  // The unique identifier of the device.
}

// RestApi -> DriverRegistry - the request message to remove a device from the device group.
message RemoveDevicesFromGroupRequest {
    string group_id           = 1;  // The unique identifier of the device group.
    repeated string device_id = 2;  // The unique identifier of the device.
}

// RestApi -> DriverRegistry - the request message to add a new device to the communication unit.
message SetDeviceCommunicationUnitsRequest {
    string device_id                                     = 1;  // The unique identifier of the device.
    repeated DeviceCommunicationUnit communication_units = 2;  // The list of linked communication units.
}

message DeviceCommunicationUnit {
    string communication_unit_id              = 1;  // The unique identifier of the communication unit.
    ApplicationProtocol app_protocol = 2;  // The application protocol to be used for the communication over the communication unit.
}

// RestApi -> DriverRegistry - the request message to get
message GetDevicesCommunicationUnitsRequest {
    repeated string device_id = 1;  // The unique identifier of the device.
}

// DriverRegistry -> RestApi - the message holds the information about the communication units linked to the device.
message GetDevicesCommunicationUnitsResponse {
    map<string, ListOfConnectionInfo> devices = 1;  // The list of devices with their communication units.
}

// Sub-message that represents the modem pool.
message ModemPoolSpec {
    string pool_id = 1;  // The modem pool identifier.
    string name    = 2;  // The name of the modem pool.
}

// RestApi -> DriverRegistry - the request message to get the modem pools.
message GetModemPoolsResponse {
    repeated ModemPoolSpec pools = 1;  // The list of modem pools.
}

// RestApi -> DriverRegistry - the request message to get the modem pool info.
message GetModemPoolRequest {
    string pool_id = 1;  // The modem pool identifier.
}

// DriverRegistry -> RestApi - the message holds the information about the modem pool.
message GetModemPoolResponse {
    repeated ModemInfo modems = 1;  // The modems registered within the pool.
    string name                        = 2;  // The name of the modem pool.
}

message SetModemPoolRequest {
    string pool_id = 1;  // The modem pool identifier. It must be unique within the system.
    string name    = 2;  // The name of the modem pool to be created. It must be unique within the system.
}

message SetModemRequest {
    string pool_id           = 1;  // The modem pool identifier, required for update operation.
    ModemInfo modem = 2;  // The modem specification.
}
