# Code generated, DO NOT EDIT.

# Result codes related to job actions
enum ActionResultCode {
  # The action has been completed successfully.
  ERROR_CODE_ACTION_OK
  # The action is not supported by the driver (or device).
  ERROR_CODE_ACTION_UNSUPPORTED
  # The action is pending.
  ERROR_CODE_ACTION_PENDING
  # The action failed.
  ERROR_CODE_ACTION_ERROR
}

# Action types
enum ActionType {
  # Get billing value, for example instantaneous values. The action covers specific register.
  ACTION_TYPE_GET_REGISTER
  # Get periodical profile, for example load-profile. The action covers specific profile column.
  ACTION_TYPE_GET_PERIODICAL_PROFILE
  # Get non-periodical profile, for example daily profile or monthly billing registers. The action covers specific profile column and or specific billing register.
  ACTION_TYPE_GET_IRREGULAR_PROFILE
  # Get event log. The action covers specific event log.
  ACTION_TYPE_GET_EVENTS
  # Get device info. The action returns info data about remote device.
  ACTION_TYPE_GET_DEVICE_INFO
  # Synchornize clock. The action synchronizes the time in the device, it can forcefully set it if force attribute is set.
  ACTION_TYPE_SYNC_CLOCK
  # Set relay state. The action covers single relay.
  ACTION_TYPE_SET_RELAY_STATE
  # Get disconnector state. The action covers single disconnector if multiple disconnectors are present in the device.
  ACTION_TYPE_GET_DISCONNECTOR_STATE
  # Set disconnector state. The action covers single relay. The action covers single disconnector if multiple disconnectors are present in the device.
  ACTION_TYPE_SET_DISCONNECTOR_STATE
  # Get time-of-use table.
  ACTION_TYPE_GET_TOU
  # Set time-of-use table.
  ACTION_TYPE_SET_TOU
  # Set limiter settings. The action covers single limiter.
  ACTION_TYPE_SET_LIMITER
  # Reseet billing period.
  ACTION_TYPE_RESET_BILLING_PERIOD
  # Start firmware update. The action updates starts FW upgrade procedure.
  ACTION_TYPE_FW_UPDATE
}

# Application protocols
enum ApplicationProtocol {
  # The IEC 62056-21 (IEC-61107, VDEW) protocol.
  APPPROTO_IEC_62056_21
  # The DLMS short-name protocol.
  APPPROTO_DLMS_SN
  # The DLMS logical-name protocol.
  APPPROTO_DLMS_LN
  # The SCTM protocol.
  APPPROTO_SCTM
  # The LIS200 protocol.
  APPPROTO_LIS200
  # The ANSI C12 protocol.
  APPPROTO_ANSI_C12
  # The MQTT protocol.
  APPPROTO_MQTT
}

# Bulk statuses
enum BulkStatusCode {
  # The job is waiting in the queue
  BULK_STATUS_QUEUED
  # The job is running
  BULK_STATUS_RUNNING
  # The job is completed
  BULK_STATUS_COMPLETED
  # The job is cancelled
  BULK_STATUS_CANCELLED
  # The job has expired
  BULK_STATUS_EXPIRED
}

# Connection types
enum CommunicationType {
  # The communication is done via direct TCP/IP.
  COMMUNICATION_TYPE_TCPIP
  # The communication is done via phone line (modem).
  COMMUNICATION_TYPE_MODEM_POOL
  # The communication is done via direct serial line.
  COMMUNICATION_TYPE_SERIAL_LINE_DIRECT
  # The communication is done via controller-serial line (Moxa).
  COMMUNICATION_TYPE_SERIAL_LINE_MOXA
  # The communication is passive, the driver is a service that listens on a port (DLMS devices in push mode) or a service that implements a subscriber to a message queue (e.g. MQTT).
  COMMUNICATION_TYPE_LISTENING
}

# Data link protocols
enum DataLinkProtocol {
  # The VDEW (IEC 62056-21, IEC-61107) protocol. In combination with DLMS protocol the driver initiates the communication by IEC and switches to the mode E to the HDLC+DLMS protocol. Supports addressing = multiple devices on the same line.
  LINKPROTO_IEC_62056_21
  # The HDLC (ISO/IEC-3309) framing. It can be used for various application protocols, such as DLMS or MODBUS. Supports client/server addressing = multiple devices on the same line.
  LINKPROTO_HDLC
  # The COSEM wrapper. It can be used for DLMS application protocol. Supports client/server addressing = multiple devices on the same line.
  LINKPROTO_COSEM_WRAPPER
  # The Modbus protocol. It shall be used for Modbus application protocol where no other data link layer, such as HDLC, is used.
  LINKPROTO_MODBUS
  # The M-Bus protocol. It shall be used for M-Bus application protocol.
  LINKPROTO_MBUS
  # The data link protocol is not applicable. It's useful for listening communication type.
  LINKPROTO_NOT_APPLICABLE
}

# Error codes related to jobs
enum JobErrorCode {
  # The job has been completed successfully.
  JOB_ERROR_CODE_NONE
  # There is no free slot in the driver to handle the job; the job shall be send again later.
  JOB_ERROR_CODE_BUSY
  # The job failed, the retry will be attempted.
  JOB_ERROR_CODE_ERROR
  # This should never happen! It means that the same job is currently being processed by the driver and it was sent to the driver mutliple times which would mean that there is a bug.
  JOB_ERROR_CODE_ALREADY_EXISTS
  # The job failed, the retry will NOT be attempted.
  JOB_ERROR_CODE_FATAL
}

# Job priorities
enum JobPriority {
  # The lowest priority
  JOB_PRIORITY_0
  # The priority 1
  JOB_PRIORITY_1
  # The priority 2
  JOB_PRIORITY_2
  # The priority 3
  JOB_PRIORITY_3
  # The priority 4
  JOB_PRIORITY_4
  # The priority 5
  JOB_PRIORITY_5
  # The priority 6
  JOB_PRIORITY_6
  # The priority 7
  JOB_PRIORITY_7
  # The highest priority
  JOB_PRIORITY_8
}

# Job statuses
enum JobStatusCode {
  # The job is waiting in the queue
  JOB_STATUS_QUEUED
  # The job is running
  JOB_STATUS_RUNNING
  # The job is completed
  JOB_STATUS_COMPLETED
  # The job is failed
  JOB_STATUS_FAILED
  # The job is cancelled
  JOB_STATUS_CANCELLED
  # The job has expired
  JOB_STATUS_EXPIRED
}

# Enum representing the field data type.
enum FieldDataType {
  # The text data type.
  TEXT
  # The integer data type.
  INTEGER
  # The double data type.
  DOUBLE
  # The boolean data type.
  BOOLEAN
  # The timestamp data type.
  TIMESTAMP
  # The binary data type.
  BINARY
}

# Enum representing the field display format.
enum FieldDisplayFormat {
  # The default display format.
  DEFAULT
  # The duration display format, e.g., 1h 30m. Data type must be integer or number; unit must be milliseconds.
  DURATION
  # The interval display format.
  INTERVAL
  # The date display format with local timezone. Data type must be timestamp or string.
  DATE
  # The date display format with in UTC timezone. Data type must be timestamp or string.
  UTC_DATE
  # The month display format.
  MONTH
  # The day of week display format.
  DAYOFWEEK
  # The time of day display format.
  TIMEOFDAY
  # The money display format.
  MONEY
  # The password display format, e.g., ********.
  PASSWORD
  # The multiline-string display format.
  MULTILINE
}

# The filter operator.
enum FilterOperator {
  # Single operand operator for text, integer, number, boolean, date fields.
  EQUAL
  # Single operand operator for text, integer, number, boolean, date fields.
  NOT_EQUAL
  # Single operand operator for integer, number, date fields.
  GREATER_THAN
  # Single operand operator for integer, number, date fields.
  GREATER_THAN_OR_EQUAL
  # Single operand operator for integer, number, date fields.
  LESS_THAN
  # Single operand operator for integer, number, date fields.
  LESS_THAN_OR_EQUAL
  # Single operand operator for text fields.
  CONTAINS
  # Single operand operator for text fields.
  NOT_CONTAINS
  # Single operand operator for text fields.
  STARTS_WITH
  # Single operand operator for text fields.
  ENDS_WITH
  # Multiple operand operator for text, integer, number, boolean fields.
  IN
  # Multiple operand operator for text, integer, number, boolean fields.
  NOT_IN
  # Two operand operator for integer, number, date fields.
  BETWEEN
  # No operand operator. For both null and empty string.
  IS_NULL
  # No operand operator. For both null and empty string.
  IS_NOT_NULL
}

# A Duration represents a signed, fixed-length span of time represented
#  as a count of seconds and fractions of seconds at nanosecond
#  resolution. It is independent of any calendar and concepts like "day"
#  or "month". It is related to Timestamp in that the difference between
#  two Timestamp values is a Duration and it can be added or subtracted
#  from a Timestamp. Range is approximately +-10,000 years.
#
#  # Examples
#
#  Example 1: Compute Duration from two Timestamps in pseudo code.
#
#      Timestamp start = ...;
#      Timestamp end = ...;
#      Duration duration = ...;
#
#      duration.seconds = end.seconds - start.seconds;
#      duration.nanos = end.nanos - start.nanos;
#
#      if (duration.seconds < 0 && duration.nanos > 0) {
#        duration.seconds += 1;
#        duration.nanos -= 1000000000;
#      } else if (duration.seconds > 0 && duration.nanos < 0) {
#        duration.seconds -= 1;
#        duration.nanos += 1000000000;
#      }
#
#  Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
#
#      Timestamp start = ...;
#      Duration duration = ...;
#      Timestamp end = ...;
#
#      end.seconds = start.seconds + duration.seconds;
#      end.nanos = start.nanos + duration.nanos;
#
#      if (end.nanos < 0) {
#        end.seconds -= 1;
#        end.nanos += 1000000000;
#      } else if (end.nanos >= 1000000000) {
#        end.seconds += 1;
#        end.nanos -= 1000000000;
#      }
#
#  Example 3: Compute Duration from datetime.timedelta in Python.
#
#      td = datetime.timedelta(days=3, minutes=10)
#      duration = Duration()
#      duration.FromTimedelta(td)
#
#  # JSON Mapping
#
#  In JSON format, the Duration type is encoded as a string rather than an
#  object, where the string ends in the suffix "s" (indicating seconds) and
#  is preceded by the number of seconds, with nanoseconds expressed as
#  fractional seconds. For example, 3 seconds with 0 nanoseconds should be
#  encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
#  be expressed in JSON format as "3.000000001s", and 3 seconds and 1
#  microsecond should be expressed in JSON format as "3.000001s".
type Duration {
  # Signed seconds of the span of time. Must be from -315,576,000,000
  #  to +315,576,000,000 inclusive. Note: these bounds are computed from:
  #  60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
  seconds: Int64
  # Signed fractions of a second at nanosecond resolution of the span
  #  of time. Durations less than one second are represented with a 0
  #  `seconds` field and a positive or negative `nanos` field. For durations
  #  of one second or more, a non-zero value for the `nanos` field must be
  #  of the same sign as the `seconds` field. Must be from -999,999,999
  #  to +999,999,999 inclusive.
  nanos: Int
}

# A generic empty message that you can re-use to avoid defining duplicated
#  empty messages in your APIs. A typical example is to use it as the request
#  or the response type of an API method. For instance:
#
#      service Foo {
#        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
#      }
type Empty {
  _empty: Boolean
}

# Wrapper message for `string`.
#
#  The JSON representation for `StringValue` is JSON string.
#
#  Not recommended for use in new APIs, but still useful for legacy APIs and
#  has no plan to be removed.
type StringValue {
  # The string value.
  value: String
}

# Sub-message containing access level definition
type AccessLevelTemplate {
  # The access level identifier, such as "1", "G", "16" or similar.
  id: String
  # The access level name. Should be in English and unique for given driver, e.g. "Management", "Public".
  name: String
}

# Sub-message containing action-based variant of data values
type ActionData {
  # No data
  nodata: Empty
  # Register values
  billings: BillingValues
  # Profile values
  profile: ProfileValues
  # Irregular (non-periodical) profile values, e.g. daily profile
  irregularProfile: IrregularProfileValues
  # Device info
  deviceInfo: DeviceInfo
  # Event records
  events: EventRecords
}

# Sub-message containing firmware update action specification
type ActionFwUpdate {
  _empty: Boolean
}

# Sub-message containing get device info action specification
type ActionGetDeviceInfo {
  _empty: Boolean
}

# Sub-message containing get events action specification
type ActionGetEvents {
  # The start timestamp of the profile.
  from: Timestamp
  # The end timestamp of the profile.
  to: Timestamp
}

# Sub-message containing get irregular profile action specification
type ActionGetIrregularProfile {
  # The start timestamp of the profile.
  from: Timestamp
  # The end timestamp of the profile.
  to: Timestamp
}

# Sub-message containing get periodical profile action specification
type ActionGetPeriodicalProfile {
  # The start timestamp of the profile.
  from: Timestamp
  # The end timestamp of the profile.
  to: Timestamp
}

# Sub-message containing get register action specification
type ActionGetRegister {
  _empty: Boolean
}

# Sub-message containing get tou action specification
type ActionGetTou {
  _empty: Boolean
}

# Sub-message containing reset billing period action specification
type ActionResetBillingPeriod {
  _empty: Boolean
}

# Sub-message containing action result for a single action.
type ActionResult {
  # The action identifier.
  actionId: String
  # The status of the action.
  status: ActionResultCode
  # The action result data.
  data: ActionData
}

# Sub-message containing set disconnector state action specification
type ActionSetDisconnectorState {
  _empty: Boolean
}

# Sub-message containing set limiter action specification
type ActionSetLimiter {
  _empty: Boolean
}

# Sub-message containing set relay state action specification
type ActionSetRelayState {
  _empty: Boolean
}

# Sub-message containing set tou action specification
type ActionSetTou {
  _empty: Boolean
}

# Sub-message containing sync clock action specification
type ActionSyncClock {
  _empty: Boolean
}

type AddCommunicationUnitsToCommunicationBusRequest {
  # The unique identifier of the communication bus.
  communicationBusId: String
  # The unique identifier of the communication unit.
  communicationUnitId: [String]
}

type AddDeviceConfigurationRegisterToDeviceConfigurationTemplateRequest {
  # The unique identifier of the device configuration template.
  templateId: String
  # The unique identifier of the register.
  registerId: String
}

type AddDevicesToGroupRequest {
  # The unique identifier of the device group.
  groupId: String
  # The unique identifier of the device.
  deviceId: [String]
}

# Sub-message containing destription for one application protocol, e.g. DLMS_SN.
type ApplicationProtocolTemplate {
  # Unique identifier of the application protocol.
  id: String
  # The application protocol.
  protocol: ApplicationProtocol
  # The list of attribute definitions for the protocol.
  attributes: [FieldDescriptor]
}

# Sub-message containing billing-typed value
type BillingValue {
  # The timestamp of the value.
  timestamp: Timestamp
  # The unit of the value.
  unit: String
  # The value.
  value: MeasuredValue
}

# Sub-message containing billing-typed values
type BillingValues {
  # The list of register values.
  values: [BillingValue]
}

type Bulk {
  # The bulk-job spec.
  spec: BulkSpec
  # The bulk-job status/data.
  status: BulkStatus
  # The metadata fields.
  metadata: MetadataFields
}

type BulkJob {
  # The job status.
  status: JobStatus
}

type BulkSpec {
  # The correlation identifier, e.g. to define relation to non-homogenous group.
  correlationId: UUID
  # The list of devices in the bulk.
  devices: ListOfJobDeviceId
  # The device group identifier.
  deviceGroupId: String
  # The bulk-shared job settings.
  settings: JobSettings
  # The list actions to be executed.
  actions: [JobAction]
  # The webhook URL to call when the bulk is completed.
  webhookUrl: String
}

type BulkStatus {
  # The job status.
  status: BulkStatusCode
  # The list of job statuses.
  jobs: [BulkJob]
}

type CommunicationBus {
  # The communication bus status.
  status: CommunicationBusStatus
  # The metadata fields.
  metadata: MetadataFields
}

type CommunicationBusStatus {
  # The list of communication unit identifiers.
  communicationUnitId: [String]
}

# Sub-message containing destription for one communication type, e.g. TCP/IP.
type CommunicationTemplate {
  # The type of the communication.
  type: CommunicationType
  # The list of data link protocols and their app protocols supported by the driver.
  datalinks: [DataLinkTemplate]
}

type CommunicationUnit {
  # The communication unit specification.
  spec: CommunicationUnitSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CommunicationUnitSpec {
  # The external identifier of the communication unit.
  externalId: String
  # The connection info.
  connectionInfo: ConnectionInfo
}

# Sub-message containing connection info
type ConnectionInfo {
  # The TCP connection type.
  tcpip: ConnectionTypeDirectTcpIp
  # The phone connection type.
  modemPool: ConnectionTypeModemPool
  # The serial over IP connection type.
  serialOverIp: ConnectionTypeControlledSerial
  # The data link protocol.
  linkProtocol: DataLinkProtocol
  # The communication bus identifier. It behaves as a custom grouping key to link jobs together across multiple communication units. It shall be used in a situation when multiple entry points share single communication bus, e.g. multi-master RS-485 (primary and backup master). If not set then jobs are grouped by group-key defined based on the connection type.
  communicationBusId: String
  # The connection attributes, see options in the DataLinkTemplate for given link_protocol.
  attributes: [_mapFieldValue]
}

# Sub-message containing connection info for controlled-serial line over IP (e.g. Moxa) connection type
type ConnectionTypeControlledSerial {
  # The simple direct serial connection type.
  direct: ConnectionTypeSerialDirect
  # The Moxa connection type.
  moxa: ConnectionTypeSerialMoxa
  # The RFC 2217 connection type.
  rfc2217: ConnectionTypeSerialRfc2217
}

# Sub-message containing connection info for TCP connection type
type ConnectionTypeDirectTcpIp {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to.
  port: Int
  # The timeout for TCP/IP connection.
  timeout: Duration
}

# Sub-message containing connection info for phone line (modem) connection type
type ConnectionTypeModemPool {
  # The phone number of the device to connect to.
  number: String
  # The modem pool identifier. The pool is a group of modems that can be used to connect to the device. Final modem is selected by the Taskmaster at the time of the job start.
  poolId: String
  # The modem device assigned to the job. This is filled only and only when the connection type is modem. The value is assigned by the Taskmaster when to job is being started. Driver is required to use this modem device to connect to the meter only and only for the time of this job!
  modem: ModemInfo
}

type ConnectionTypeSerialDirect {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to.
  port: Int
  # The timeout for direct serial port connection.
  timeout: Duration
}

# Sub-message containing connection info for controlled-serial line (Moxa) connection type
type ConnectionTypeSerialMoxa {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to - data port.
  dataPort: Int
  # The TCP port number of the device to connect to - command port.
  commandPort: Int
  # The timeout for serial port connection that implements the Moxa protocol.
  timeout: Duration
}

# Sub-message containing connection info for controlled-serial line (RFC 2217) connection type
type ConnectionTypeSerialRfc2217 {
  # The host name or IP address of the device to connect to.
  host: String
  # The TCP port number of the device to connect to.
  port: Int
  # The timeout for serial port connection that implements the RFC 2217 protocol.
  timeout: Duration
}

type CreateBulkRequest {
  # The bulk-job spec.
  spec: BulkSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateCommunicationBusRequest {
  # The metadata fields.
  metadata: MetadataFields
}

type CreateCommunicationUnitRequest {
  # The communication unit specification.
  spec: CommunicationUnitSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceConfigurationRegisterRequest {
  # The register specification.
  spec: DeviceConfigurationRegisterSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceConfigurationTemplateRequest {
  # The device configuration template specification.
  spec: DeviceConfigurationTemplateSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceGroupRequest {
  # The device group specification.
  spec: DeviceGroupSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateDeviceRequest {
  # The device specification.
  spec: DeviceSpec
  # The metadata fields.
  metadata: MetadataFields
}

type CreateProxyBulkRequest {
  # The proxy bulk-job spec.
  spec: ProxyBulkSpec
  # The metadata fields.
  metadata: MetadataFields
}

# Sub-message containing destription for one data link protocol, e.g. HDLC.
type DataLinkTemplate {
  # The data link protocol.
  linkProtocol: DataLinkProtocol
  # The list of application protocol identifiers supported by the driver.
  appProtocolRefs: [ApplicationProtocol]
  # The list of attribute definitions related to given data link type (see link_protocol property) and all those will be instantiated for each device.
  attributes: [FieldDescriptor]
}

type Device {
  # The device specification.
  spec: DeviceSpec
  # The device status.
  status: DeviceStatus
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceCommunicationUnit {
  # The unique identifier of the communication unit.
  communicationUnitId: String
  # The application protocol to be used for the communication over the communication unit.
  appProtocol: ApplicationProtocol
}

type DeviceConfigurationRegister {
  # The register specification.
  spec: DeviceConfigurationRegisterSpec
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceConfigurationRegisterSpec {
  # The device (driver) type.
  driverType: String
  # The type of action for which the register is defined.
  actionType: ActionType
  # The field values.
  attributes: [_mapFieldValue]
}

type DeviceConfigurationTemplate {
  # The device configuration template specification.
  spec: DeviceConfigurationTemplateSpec
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceConfigurationTemplateSpec {
  # The device (driver) type.
  driverType: String
  # The list of device configuration register identifiers.
  registerId: [String]
}

type DeviceGroup {
  # The device group specification.
  spec: DeviceGroupSpec
  # The device group status.
  status: DeviceGroupStatus
  # The metadata fields.
  metadata: MetadataFields
}

type DeviceGroupSpec {
  # The external identifier of the communication unit.
  externalId: String
  # The list selector used over Device object to dynamically select devices.
  dynamicFilter: ListSelector
}

type DeviceGroupStatus {
  # The list of devices that are part of the group. The key represents the device identifier, the value contains additional information.
  devices: [_mapDeviceGroupStatusDevice]
}

type DeviceGroupStatusDevice {
  # The driver type.
  driverType: String
}

# Message holds common device information.
type DeviceInfo {
  # The timestamp when the values were read.
  infoTimestamp: Timestamp
  # The serial number of the device set by manufacturer. Typical source: 0-0:42.0.0.255
  manufacturerSerialNumber: String
  # The device serial number of the device.  Typical source: 0-0:96.1.0.255
  deviceSerialNumber: String
  # The firmware version identifier of the device. Typical source: 0-0:0.2.0.255
  firmwareVersion: String
  # The clock delta against acquisition server clock (got by a driver) where positive value means that the device clock is ahead of local clock and vice versa.
  clockDelta: Duration
  # The model of the device.
  deviceModel: String
  # The error register 0. Typical source: 0-0:97.97.1.255 (higher 32-bit) + 0-0:97.97.0.255 (lower 32-bit)
  errorRegister: BigInt
  # The list of relay states. The order of the relays is the same as in the device. The value is true if the relay is connected and false if the relay is disconnected.
  relayStates: [Boolean]
  # The state of the connection. It represents the disconnector state where true means that the customer is connected and false means that the customer is disconnected.
  connectionState: Boolean
}

# Sub-message - the device specification.
type DeviceSpec {
  # The driver type identifier.
  driverType: String
  # The external identifier of the device.
  externalId: String
  # The template of the action attributes. It is represented as a list of attribute definitions.
  attributes: [_mapFieldValue]
  # The list of communication unit identifiers (and additional info) that set CUs usable to communicate with the device. It's an ordered set where the first element is the primary communication unit with the highest priority.
  communicationUnitLink: [DeviceCommunicationUnit]
  # The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
  timezone: String
}

type DeviceStatus {
  # The device info.
  info: DeviceInfo
}

type Driver {
  # The driver specification.
  spec: DriverSpec
}

type DriverSpec {
  # The driver version. The format is not defined. The driver itself is versioned by the docker image tags so this value shall be either the same (set during the image build) or any useful user-readable version string.
  version: String
  # The port the driver's gRPC will listen on.
  listeningPort: Int
  # The technical/internal ID of the driver.
  driverType: String
  # The maximum number of concurrent jobs the driver can handle. The value 0 is not allowed, the maximum number respect typical_mem_usage not to overgrow the memory resources!
  maxConcurrentJobs: Int
  # The maximum cascade depth the driver can handle. Number 1 means that the driver cannot handle cascading jobs, 2 means that the driver can handle cascading jobs with one level of depth, etc.
  #  The value 0 means that the driver can handle any number of cascading jobs.
  maxCascadeDepth: Int
  # The typical memory usage of the driver in MB.
  typicalMemUsage: Int
  # The connection and action templates.
  templates: DriverTemplates
  # The display name of the driver. Must be in format '<manufacturer> <device_type> [<device_type_version>]'.
  #  It must respect upper/lower characters.
  #  The generic drivers, such as 'cybros labs generic', must be named as '<driver_company_name> generic'.
  #
  #  Examples: 'Addax NP73E', 'cybros labs generic', 'Landis+Gyr S650 v2'
  displayName: String
}

# Sub-message in driver negotiation request
type DriverTemplates {
  # The templates of the communication options. Every template represents an option how the drivers allows to communicate. The driver can support multiple communication templates.
  communicationTemplates: [CommunicationTemplate]
  # The templates of the application protocols supported by the driver.
  appProtocols: [ApplicationProtocolTemplate]
  # The templates of the job actions for all supported action types. It must contain every action type supported by the driver once and only once.
  actionAttributes: [JobActionAttributes]
  # The templates of the access levels supported by the driver.
  accessTemplates: [AccessLevelTemplate]
  # The templates of the job actions constraints.
  actionConstraints: JobActionContraints
}

# Sub-message describing a single event.
type EventRecord {
  # The timestamp of the event.
  timestamp: Timestamp
  # The identifier of the event.
  eventId: Int64
  # The code of the event as generated by the device.
  eventCode: Int64
  # The text of the event.
  eventText: String
  # The event source.
  eventSource: String
}

# Sub-message containing event records
type EventRecords {
  # The list of events.
  values: [EventRecord]
}

type IrregularProfileValues {
  # The unit of the profile values.
  unit: String
  # The list of continuous profile blocks.
  values: [IrregularValue]
}

type IrregularValue {
  # The timestamp of the value.
  timestamp: Timestamp
  # The value.
  value: MeasuredValue
}

# Sub-message containing job action specification
type JobAction {
  # The action identifier.
  actionId: String
  # The action attributes.
  attributes: [_mapFieldValue]
  # The get register action specification.
  getRegister: ActionGetRegister
  # The get periodical profile action specification.
  getPeriodicalProfile: ActionGetPeriodicalProfile
  # The get irregular profile action specification.
  getIrregularProfile: ActionGetIrregularProfile
  # The get events action specification.
  getEvents: ActionGetEvents
  # The get device info action specification.
  getDeviceInfo: ActionGetDeviceInfo
  # The sync clock action specification.
  syncClock: ActionSyncClock
  # The set relay state action specification.
  setRelayState: ActionSetRelayState
  # The set disconnector state action specification.
  setDisconnectorState: ActionSetDisconnectorState
  # The get tou action specification.
  getTou: ActionGetTou
  # The set tou action specification.
  setTou: ActionSetTou
  # The set limiter action specification.
  setLimiter: ActionSetLimiter
  # The reset billing period action specification.
  resetBillingPeriod: ActionResetBillingPeriod
  # The firmware update action specification.
  fwUpdate: ActionFwUpdate
}

# Sub-message containing job action attributes
type JobActionAttributes {
  # The type of action for which this instance of the template is defined.
  type: ActionType
  # The template of the action attributes. It is represented as a list of attribute definitions.
  attributes: [FieldDescriptor]
}

# Sub-message containing constraints for job actions.
type JobActionContraints {
  # Contains all the register types & their names in the English language. For example: [gen]="Generic Register", [vqi]="Quality VQI Register"
  #  Action: ACTION_TYPE_GET_REGISTER
  getRegisterTypeName: [_mapstring]
  # Contains all the register types & their attributes. For example: [gen]=["attribute1", "attribute2"], [vqi]=["attribute1", "attribute3"]
  #  See JobActionAttributes for the attribute definitions.
  #  Action: ACTION_TYPE_GET_REGISTER
  getRegisterTypeAttributes: [_mapListOfString]
}

# Sub-message representing a single job-device info.
type JobDevice {
  # The device's job identifier within the parent bulk.
  jobId: String
  # The device identifier. If set then all below is loaded from the device registry.
  deviceId: String
  # The external identifier.
  externalId: String
  # The connection attributes to the device.
  deviceAttributes: [_mapFieldValue]
  # The connection (device) parameters.
  connectionInfo: [ConnectionInfo]
  # The application protocol.
  appProtocol: ApplicationProtocol
  # The timezone related to the device, e.g. "America/New_York", "Europe/Prague", "CET", "GMT", "Etc/GMT+2".
  timezone: String
}

type JobDeviceId {
  # The device's job identifier within the parent bulk.
  jobId: String
  # The device identifier.
  deviceId: String
}

# Sub-message containing job parameters
type JobSettings {
  # Maximum duration of the job attempt. This is related to the real time for the driver.
  maxDuration: Duration
  # Priority of the job.
  priority: JobPriority
  # Maximum number of attempts, 1 is the minimum.
  attempts: [Int]
  # Delay between two attempts.
  retryDelay: Duration
  # Time to wait before starting the job.
  deferStart: Duration
  # The timestamp when the job expires.
  expiresAt: Timestamp
}

# Sub-message containing job status info
type JobStatus {
  # The status of the job.
  status: JobStatusCode
  # The error code of the job.
  code: JobErrorCode
  # The result data for all job actions.
  results: [ActionResult]
  # The creation timestamp of the job.
  createdAt: Timestamp
  # The start timestamp of the job.
  startedAt: Timestamp
  # The finish timestamp of the job.
  finishedAt: Timestamp
  # The number of attempts already done.
  attemptsDone: Int
  # The device info. It contains the data from the action ACTION_TYPE_GET_DEVICE_INFO.
  deviceInfo: DeviceInfo
  # The internal queue identifier set by the Taskmaster when the job is queued to process.
  queueId: Int64
}

type ListOfBulk {
  # The list of bulks.
  items: [Bulk]
  # The total number of items.
  totalCount: Int
}

type ListOfCommunicationBus {
  # The list of communication unit buses.
  items: [CommunicationBus]
  # The total number of items.
  totalCount: Int
}

type ListOfCommunicationUnit {
  # The communication unit specification.
  items: [CommunicationUnit]
  # The total number of items.
  totalCount: Int
}

type ListOfDevice {
  # The list of devices.
  items: [Device]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceCommunicationUnit {
  # The list of linked communication units.
  items: [DeviceCommunicationUnit]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceConfigurationRegister {
  # The list of registers.
  items: [DeviceConfigurationRegister]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceConfigurationTemplate {
  # The list of device configuration templates.
  items: [DeviceConfigurationTemplate]
  # The total number of items.
  totalCount: Int
}

type ListOfDeviceGroup {
  # The list of device groups.
  items: [DeviceGroup]
  # The total number of items.
  totalCount: Int
}

type ListOfDriver {
  # The list of drivers.
  items: [Driver]
  # The total number of items.
  totalCount: Int
}

type ListOfJobDevice {
  # The list of devices in the bulk.
  list: [JobDevice]
  # The total number of items.
  totalCount: Int
}

type ListOfJobDeviceId {
  # The list of devices in the bulk.
  list: [JobDeviceId]
  # The total number of items.
  totalCount: Int
}

type ListOfModemPool {
  # The list of modem pools.
  items: [ModemPool]
  # The total number of items.
  totalCount: Int
}

# Sub-message containing measured value
type MeasuredValue {
  # The status of the value.
  status: Int64
  # The exponent of the value. It's used to calculate the real value as value * 10^exponent for double and int values.
  exponent: Int
  # The double-typed value.
  doubleValue: Float
  # The integer-typed value.
  integerValue: Int64
  # The string-typed value.
  stringValue: String
  # The timestamp-typed value.
  timestampValue: Timestamp
  # The timestamp with timezone-typed value, stored as string in ISO-8601.
  timestampTzValue: String
  # The boolean-typed value.
  boolValue: Boolean
}

# Sub-message containing modem connection info
type ModemInfo {
  # The modem identifier. It is automatically generated during creation.
  modemId: String
  # The name of the modem.
  name: String
  # The modem initialization command, e.g. AT&FE0X3
  atInit: String
  # The modem dial command, e.g. ATD.
  atDial: String
  # The modem hangup command, e.g. ATH.
  atHangup: String
  # The modem escape command, e.g. +++.
  atEscape: String
  # The modem connection timeout, if applicable given by the modem_connection field.
  connectTimeout: Duration
  # The modem command timeout, if applicable given by the modem_connection field.
  commandTimeout: Duration
  # The TCP connection type. The modem has either TCP or there is a IP-to-serial converter which handles the serial configuration so no additional serial configuration is needed.
  tcpip: ConnectionTypeDirectTcpIp
  # The serial over IP connection type. The modem is connected behind an IP-to-serial converter and needs connection specific handling.
  serialOverIp: ConnectionTypeControlledSerial
  # The serial baud rate, if applicable given by the modem_connection field.
  serialBaudRate: Int
}

type ModemPool {
  # The modem pool specification.
  spec: ModemPoolSpec
  # The modem pool status.
  status: ModemPoolStatus
  # The metadata fields.
  metadata: MetadataFields
}

type ModemPoolSpec {
  _empty: Boolean
}

type ModemPoolStatus {
  # The list of modems in the pool.
  modems: [ModemInfo]
}

# Sub-message containing a single profile block
type ProfileBlok {
  # The start timestamp of the block.
  startTimestamp: Timestamp
  # The list of profile values. Values are ordered by timestamp.
  values: [MeasuredValue]
}

# Sub-message containing profile-typed values
type ProfileValues {
  # The period of the profile values.
  period: Int
  # The unit of the profile values.
  unit: String
  # The list of continuous profile blocks.
  blocks: [ProfileBlok]
}

type ProxyBulkSpec {
  # The correlation identifier, e.g. to define relation to non-homogenous group.
  correlationId: UUID
  # The device (driver) type.
  driverType: String
  # The list of custom devices in the bulk.
  devices: ListOfJobDevice
  # The bulk-shared job settings.
  settings: JobSettings
  # The list actions to be executed.
  actions: [JobAction]
  # The webhook URL to call when the bulk is completed.
  webhookUrl: String
}

type RemoveCommunicationUnitsFromCommunicationBusRequest {
  # The unique identifier of the communication bus.
  communicationBusId: String
  # The unique identifier of the communication unit.
  communicationUnitId: [String]
}

type RemoveDeviceConfigurationRegisterFromDeviceConfigurationTemplateRequest {
  # The unique identifier of the device configuration template.
  templateId: String
  # The unique identifier of the register.
  registerId: String
}

type RemoveDevicesFromGroupRequest {
  # The unique identifier of the device group.
  groupId: String
  # The unique identifier of the device.
  deviceId: [String]
}

type SetDeviceCommunicationUnitsRequest {
  # The unique identifier of the device.
  deviceId: String
  # The list of linked communication units.
  communicationUnits: [DeviceCommunicationUnit]
}

type SetModemPoolRequest {
  # The modem pool specification.
  spec: ModemPoolSpec
  # The metadata fields.
  metadata: MetadataFields
}

type SetModemRequest {
  # The modem pool identifier, required for update operation.
  poolId: String
  # The modem specification.
  modem: ModemInfo
}

# The field descriptor.
type FieldDescriptor {
  # Unique identifier for the field
  fieldId: String
  # Label displayed for the field
  label: String
  # Data type of the field (e.g., text, double)
  dataType: FieldDataType
  # Display format (e.g., 1h 30m)
  format: FieldDisplayFormat
  # Unit to display (e.g., kWh, USD)
  unit: String
  # Group (section) identifier for the field
  groupId: String
  # Decimal precision for double numbers
  precision: Int
  # Tooltip or hint text
  tooltip: String
  # Whether the field is mandatory
  required: Boolean
  # Whether the field is editable
  editable: Boolean
  # Whether the field is visible
  visible: Boolean
  # Whether the field can have multiple values
  multiValue: Boolean
  # Whether the field shall be handled as a security fields (e.g., password, certificate input area, ...)
  secured: Boolean
  # Validation rules for the field
  validation: FieldValidation
  # The default value of the attribute, it does not support multi-value fields
  defaultValue: FieldValue
  # The path to the field in the JSON data model
  jsPath: String
}

# Validation rules for the field.
type FieldValidation {
  # Regular expression describing input format. If not set then any value of given type can be used. It can be used for string, int or double fields only.
  re: String
  # The minimum length. It's used for string fields only.
  minLength: Int
  # The maximum length. It's used for string fields only.
  maxLength: Int
  # The minimum value. It's used for integer fields only.
  minInteger: Int64
  # The maximum value. It's used for integer fields only.
  maxInteger: Int64
  # The minimum value. It's used for number fields only.
  minNumber: Float
  # The maximum value. It's used for number fields only.
  maxNumber: Float
  # The list of allowed values to be set (key-value pairs). The key here represents the field value to be set and the value here represents the label to be displayed.
  options: [_mapstring]
}

type FieldValue {
  # Represents a string-typed value.
  stringValue: String
  # Represents a 64-bit integer-typed value.
  integerValue: Int64
  # Represents a 64-bit double-typed value.
  doubleValue: Float
  # Represents a binary-typed value.
  binaryValue: String
  # Represents a boolean-typed value.
  boolValue: Boolean
  # Represents a date-typed value.
  dateValue: Timestamp
}

type ListOfFieldDescriptor {
  # The list of field descriptors.
  items: [FieldDescriptor]
  # The total number of items.
  totalCount: Int
}

# The list of string items.
type ListOfString {
  # Generic list of string items.
  items: [String]
  # The total number of items.
  totalCount: Int
}

# The listing selector.
type ListSelector {
  # The number of items per page.
  pageSize: Int
  # The offset of the first item to return, zero based.
  offset: Int
  # The sorting criteria.
  sortBy: [ListSelectorSortBy]
  # The filtering criteria.
  filterBy: [ListSelectorFilterBy]
  # FIXME: This needs to be designed properly.
  #
  # The list of additional fields to be returned.
  fields: [String]
}

# The filtering criteria.
#
#  Depending on the operator, the 'text', 'integer', 'number', 'boolean' or 'date' field should be used.
#  - No value must be set for operators: 'IS_NULL', 'IS_NOT_NULL'.
#  - One value must be set for single operand operators: 'EQUAL', 'NOT_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'CONTAINS', 'NOT_CONTAINS', 'STARTS_WITH', 'ENDS_WITH'.
#  - Two values must be set for two operand operators: 'BETWEEN'.
#  - Any number of values can be set for generic operators: 'IN', 'NOT_IN'.
#
#  Field type determines the data type and only related field should be used. Other fields shall not be set and will be ignored by the system.
type ListSelectorFilterBy {
  # Field id.
  fieldId: String
  # The filter operator.
  operator: FilterOperator
  # The data type of the field.
  dataType: FieldDataType
  # The text-typed value(s) used for filtering.
  text: [String]
  # The integer-typed value(s) used for filtering.
  integer: [Int64]
  # The number-typed value(s) used for filtering.
  number: [Float]
  # The boolean-typed value(s) used for filtering.
  boolean: [Boolean]
  # The date-typed value(s) used for filtering.
  date: [Timestamp]
}

# The sorting criteria.
type ListSelectorSortBy {
  # Field id.
  fieldId: String
  # Set to true to sort in descending order.
  desc: Boolean
}

# The metadata fields managed by user and system.
type MetadataFields {
  # The UUID of the resource. It serves as the unique identifier of the resource. It's immutable and typically auto-generated during Create operations.
  id: String
  # The generation of the resource.
  generation: Int
  # The additional fields managed by user.
  fields: [_mapFieldValue]
  # The additional fields managed by system.
  managedFields: [_mapFieldValue]
  # The name of the resource. It's mutable and typically set by user. Must be set.
  name: String
}

type SystemConfig {
  # The maximum number of replicas for all drivers.
  #     0 represents no active replicas will run, effectively disabling acquisition
  #    >0 represents the maximum number of replicas per driver
  maxReplicas: Int
  # The maximum number of cascade devices for the driver. Minimum is 1.
  maxCascadeDeviceCount: Int
  # The maximum number of slots per driver
  #    -1 represents unlimited number of slots, effecticaly using maximum number of slots supported by driver
  #     0 represents no active slots will run, effectively disabling acquisition
  #    >0 represents the maximum number of slots per driver, the number of slots never exceeds the number of slots supported by driver
  maxSlotsPerDriver: Int
  # The minimum number of replicas per type of driver.
  #  The key is the driver type, the value is the minimum number of replicas.
  #  The minimum replicas is guaranteed to be running at all times even if the total number of replicas exceeds the maximum number of replicas set in max_replicas.
  minReplicas: [_mapint32]
  # Disable data proxy to process data from ouro temp tables.
  disableDataProxyProcessing: Boolean
}

type _mapFieldValue {
  key: String!
  value: FieldValue
}

type _mapDeviceGroupStatusDevice {
  key: String!
  value: DeviceGroupStatusDevice
}

type _mapstring {
  key: String!
  value: String
}

type _mapListOfString {
  key: String!
  value: ListOfString
}

type _mapint32 {
  key: String!
  value: Int
}

type Query {
  createProxyBulk: StringValue
  createBulk: StringValue
  listBulks: ListOfBulk
  getBulk: Bulk
  cancelBulk: Empty
  getBulkJob: BulkJob
  getConfig: SystemConfig
  setConfig: Empty
  createDeviceConfigurationRegister: StringValue
  listDeviceConfigurationRegisters: ListOfDeviceConfigurationRegister
  getDeviceConfigurationRegister: DeviceConfigurationRegister
  updateDeviceConfigurationRegister: Empty
  deleteDeviceConfigurationRegister: Empty
  createDeviceConfigurationTemplate: StringValue
  listDeviceConfigurationTemplates: ListOfDeviceConfigurationTemplate
  getDeviceConfigurationTemplate: DeviceConfigurationTemplate
  updateDeviceConfigurationTemplate: Empty
  deleteDeviceConfigurationTemplate: Empty
  addDeviceConfigurationRegisterToDeviceConfigurationTemplate: Empty
  removeDeviceConfigurationRegisterFromDeviceConfigurationTemplate: Empty
  createCommunicationUnit: StringValue
  listCommunicationUnits: ListOfCommunicationUnit
  getCommunicationUnit: CommunicationUnit
  createCommunicationBus: StringValue
  listCommunicationBuses: ListOfCommunicationBus
  addCommunicationUnitsToCommunicationBus: Empty
  removeCommunicationUnitsFromCommunicationBus: Empty
  createDevice: StringValue
  listDevices: ListOfDevice
  getDevice: Device
  setDeviceCommunicationUnits: Empty
  getDeviceCommunicationUnits: ListOfDeviceCommunicationUnit
  createDeviceGroup: StringValue
  listDeviceGroups: ListOfDeviceGroup
  getDeviceGroup: DeviceGroup
  addDevicesToGroup: Empty
  removeDevicesFromGroup: Empty
  listDeviceGroupDevices: ListOfDevice
  listModemPools: ListOfModemPool
  getModemPool: ModemPool
  createModemPool: StringValue
  updateModemPool: Empty
  deleteModemPool: Empty
  createModem: StringValue
  updateModem: Empty
  deleteModem: Empty
  listDrivers: ListOfDriver
  getDriver: Driver
  listFieldDescriptors: ListOfFieldDescriptor
}

scalar Timestamp
scalar BigInt
scalar Int64
scalar UUID
